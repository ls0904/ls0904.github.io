<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>webpack具体配置详情</title>
      <link href="/2019/07/18/webpack-ju-ti-pei-zhi-xiang-qing-v4.0/"/>
      <url>/2019/07/18/webpack-ju-ti-pei-zhi-xiang-qing-v4.0/</url>
      
        <content type="html"><![CDATA[<h2 id="webpack看这一篇就够了，webpack4-0配置详解。"><a href="#webpack看这一篇就够了，webpack4-0配置详解。" class="headerlink" title="webpack看这一篇就够了，webpack4.0配置详解。"></a>webpack看这一篇就够了，webpack4.0配置详解。</h2><p>什么是webpack，webpack给我们解决了哪些实际问题？</p><ul><li>什么是webpack?<br> webpack 它是基于 Node.js 开发出来的是前端的一个项目构建工具。</li><li>webpack给我们解决了哪些实际的问题？<br> 你是否和我一样整天被这种包与包之间的依赖关系搞得头皮发麻。比如你需要用到<code>easyUI</code>那么你就得引入<code>jQuery</code>,并且<code>jQuery</code>必须在<code>easyUI</code>引入之前引入。那这个就有点烦了,每个页面都必须引入。<br> 引入过多的静态资源后，网页打开需要的二次请求量也就高了，这样网页打开就会比较慢，那么项目经理找你的次数也会增加，加班次数增加，啊啊啊啊！<br> 这时候webpack就来了，可以很好的解决以上的问题，从此再也不用加班了。</li></ul><blockquote><p>tips:除了<code>webpack</code>这个打包工具外还有<code>Gulp</code>也比较常见。</p></blockquote><ul><li><p>webpack完美实现资源的合并、打包、压缩、混淆等诸多功能。 </p><ul><li>从此写代码无烦恼，天天吃饭吃的好。</li></ul><blockquote><p><a href="http://webpack.github.io/" target="_blank" rel="noopener">webpack官网</a></p></blockquote></li></ul><h2 id="webpack的安装"><a href="#webpack的安装" class="headerlink" title="webpack的安装"></a>webpack的安装</h2><ol><li><code>npm i webpack -g</code>全局安装webpack，这样就能在全局使用webpack的命令</li><li>在项目根目录中运行<code>npm i webpack -D</code>安装到项目开发依赖中</li></ol><h2 id="webpack的配置文件"><a href="#webpack的配置文件" class="headerlink" title="webpack的配置文件"></a>webpack的配置文件</h2><ul><li>其实<code>webpack</code>也可以不需要配置文件，然后就靠输命令来构建。(如果你喜欢你可以在项目上试试,公司第二天辞退QAQ)</li><li>使用<code>webpack</code>的配置文件。</li></ul><ol><li><p>首先创建<code>webpack</code>的配置文件，在项目根目录创建<code>webpack.config.js</code>。</p></li><li><p>配置</p><pre><code>webpack</code></pre><p>,你得先清楚这两个概念:’出口(output)’和’入口(entry)’。 </p><ul><li>入口就相当于工厂中的原材料，出口就是做成的产品（够形象了吧）。</li><li>入口简单讲就是你自己写的代码，出口呢就是<code>webpack</code>帮你处理过后的代码（你：’我为什么要给他处理，我自己不知道我写的啥吗？‘。先别抬杠，别着急慢慢看）。<br> <code>webpack.config.js</code>简单的配置文件如下：</li></ul></li></ol><pre class=" language-javascript"><code class="language-javascript">    <span class="token comment" spellcheck="true">// 导入处理路径的模块</span>    <span class="token keyword">var</span> path <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'path'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 导出一个配置对象，将来webpack在启动的时候，会默认查找`webpack.config.js`，并读取这个文件中配置，来进行打包</span>    module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 入口文件</span>        entry<span class="token punctuation">:</span> path<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span> <span class="token string">'./src/main.js'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>         <span class="token comment" spellcheck="true">// 出口文件</span>        output<span class="token punctuation">:</span> <span class="token punctuation">{</span>             <span class="token comment" spellcheck="true">// 出口的路径</span>            path<span class="token punctuation">:</span> path<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span> <span class="token string">'dist'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>             <span class="token comment" spellcheck="true">// 出口的文件名</span>            filename<span class="token punctuation">:</span> <span class="token string">'bundle.js'</span>         <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><p>这样你在项目根目录执行<code>webpack</code>命令就会帮你把<code>main.js</code>给打包成<code>bundle.js</code>然后你以后只需要引入<code>bundle.js</code>就行了,是不是很神奇。</p><ul><li><p>把</p><pre><code>main.js</code></pre><p>打包的意义： </p><ol><li>我们可以使用ES6提供的模块化进行代码的编写了。（配置<code>babel</code>之后）</li><li>我们可以直接在js文件上引入样式了。</li><li>代码美观冗余的代码很少很少了。</li></ol></li></ul><blockquote><p>大体了解了吧</p></blockquote><ul><li><p>我们这样配置后有个问题，我们每次修改代码都必须重新打包，一个字：麻烦。</p></li><li><p>使用</p><pre><code>webpack-dev-server</code></pre><p>来实现代码的实时打包。 </p><ul><li>首先<code>npm i webpack-dev-server -D</code>安装一下<code>webpack-dev-server</code> </li><li>直接输<code>webpack-dev-server</code>会报错，这里我们得借助<code>package.json</code>来进行打包，在<code>scripts</code>下增加<code>"dev": "webpack-dev-server"</code>指令，然后<code>npm run dev</code>,就能实时打包了。</li><li>使用<code>webpack-dev-server</code>的打包是不会产生出口文件的，他是将出口文件放在内存里，这样来做到实时读取和实时打包的。</li><li>默认启动端口是8080我们可以<code>webpack-dev-server --port 3000</code>来指定端口</li><li>默认启动是在项目根目录，我们可以<code>webpack-dev-server --port 3000 --contentBase src</code>让其在<code>./src</code>中启动</li><li>可以配置热更新，就不用每次刷新了，<code>webpack-dev-server --port 3000 --contentBase src --hot</code> </li><li>每次都得手动开启浏览器，不喜欢，我们可以让其构建时自动打开浏览器<code>webpack-dev-server --port 3000 --contentBase src --hot --open</code> </li><li>html文件没进内存-_-!,我们可以配置插件<code>html-webpack-plugin</code>插件</li></ul></li></ul><blockquote><p> // 导入处理路径的模块<br>var path = require(‘path’);<br>//自动生成html文件<br>var htmlWebpackPlugin = require(‘html-webpack-plugin’);<br>// 导出一个配置对象，将来webpack在启动的时候，会默认查找<code>webpack.config.js</code>，并读取这个文件中配置，来进行打包<br>module.exports = {<br>            // 入口文件<br>            entry: path.resolve(<strong>dirname, ‘./src/main.js’),<br>            // 出口文件<br>            output: {<br>            // 出口的路径<br>            path: path.resolve(</strong>dirname, ‘dist’),<br>            // 出口的文件名<br>        filename: ‘bundle.js’<br>    },<br>    plugins:[<br>            new htmlWebpackPlugin({<br>                //模板路径<br>                template:path.resolve(__dirname, ‘src/index.html’),<br>                //生成的HTML文件的名称<br>            filename:’index.html’<br>        })<br>    ]<br>}</p></blockquote><pre class=" language-javascript"><code class="language-javascript"> <span class="token operator">+</span> 这里就不需要再配置<span class="token template-string"><span class="token string">`--contentBase src`</span></span>了，<span class="token template-string"><span class="token string">`html-webpack-plugin`</span></span>插件会自动把bundle<span class="token punctuation">.</span>js注入到index<span class="token punctuation">.</span>html页面中！（好玩吧）    <span class="token operator">+</span> 最终在packjson的<span class="token template-string"><span class="token string">`script`</span></span>中增加这个：<span class="token template-string"><span class="token string">` "dev":"webpack-dev-server --port 3000 --hot --open" `</span></span>    <span class="token operator">+</span> 除了加命令参数外，我们还可以在配置文件中进行配置增加        <span class="token number">1</span><span class="token punctuation">.</span> 第一步在配置项中增加<span class="token template-string"><span class="token string">``</span></span><span class="token template-string"><span class="token string">`javascriptdevServer:{    port:3000    hot:true,    open:true}    2. 在头部加载`</span></span>webpack<span class="token template-string"><span class="token string">`模块：var webpack = require('webpack');    3. 在`</span></span>plugins`下新增插件（热部署）：<span class="token keyword">new</span> <span class="token class-name">webpack<span class="token punctuation">.</span>HotModuleReplacementPlugin</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><h2 id="使用webpack来打包css文件"><a href="#使用webpack来打包css文件" class="headerlink" title="使用webpack来打包css文件"></a>使用<code>webpack</code>来打包<code>css</code>文件</h2><pre class=" language-javascript"><code class="language-javascript"><span class="token operator">+</span> 是的，css也能打包，包括<span class="token template-string"><span class="token string">`less,sacc`</span></span>都行的只是<span class="token template-string"><span class="token string">`loader`</span></span>不一样    <span class="token number">1</span><span class="token punctuation">.</span> 安装需要的<span class="token template-string"><span class="token string">`loader`</span></span>，运行<span class="token template-string"><span class="token string">`npm i style-loader css-loader -D`</span></span>     <span class="token number">2</span><span class="token punctuation">.</span> 修改配置文件增加<span class="token template-string"><span class="token string">`module`</span></span>项配置<span class="token comment" spellcheck="true">// 配置第三方loader模块</span>module<span class="token punctuation">:</span> <span class="token punctuation">{</span>         rules<span class="token punctuation">:</span> <span class="token punctuation">[</span>             <span class="token punctuation">{</span>                 <span class="token comment" spellcheck="true">// 正则匹配所有的.css文件</span>                test<span class="token punctuation">:</span> <span class="token regex">/\.css$/</span><span class="token punctuation">,</span>                 <span class="token comment" spellcheck="true">//处理css文件的loader</span>                use<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'style-loader'</span><span class="token punctuation">,</span> <span class="token string">'css-loader'</span><span class="token punctuation">]</span>             <span class="token punctuation">}</span>        <span class="token punctuation">]</span>    <span class="token punctuation">}</span></code></pre><blockquote><p>注意：<code>use</code>表示使用哪些<code>loader</code>来处理<code>test</code>所匹配到的文件；<code>use</code><br> 中相关<code>loader</code>模块的调用顺序是从<strong>后向前</strong>调用的；（自己第一次的时候就入坑了）</p></blockquote><h2 id="使用webpack打包less文件"><a href="#使用webpack打包less文件" class="headerlink" title="使用webpack打包less文件"></a>使用webpack打包less文件</h2><ol><li>下载需要的loader<code>npm i less-loader less -D</code> </li><li>修改配置文件：</li></ol><pre class=" language-javascript"><code class="language-javascript">module<span class="token punctuation">:</span> <span class="token punctuation">{</span>         rules<span class="token punctuation">:</span> <span class="token punctuation">[</span>             <span class="token punctuation">{</span>                 <span class="token comment" spellcheck="true">// 正则匹配所有的.css文件</span>                test<span class="token punctuation">:</span> <span class="token regex">/\.css$/</span><span class="token punctuation">,</span>                 <span class="token comment" spellcheck="true">//处理css文件的loader</span>                use<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'style-loader'</span><span class="token punctuation">,</span> <span class="token string">'css-loader'</span><span class="token punctuation">]</span>             <span class="token punctuation">}</span><span class="token punctuation">,</span>            <span class="token punctuation">{</span>                 test<span class="token punctuation">:</span> <span class="token regex">/\.less$/</span><span class="token punctuation">,</span>                use<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'style-loader'</span><span class="token punctuation">,</span> <span class="token string">'css-loader'</span><span class="token punctuation">,</span> <span class="token string">'less-loader'</span><span class="token punctuation">]</span>             <span class="token punctuation">}</span>        <span class="token punctuation">]</span>    <span class="token punctuation">}</span></code></pre><h2 id="使用webpack打包sass文件"><a href="#使用webpack打包sass文件" class="headerlink" title="使用webpack打包sass文件"></a>使用webpack打包sass文件</h2><ol><li>下载需要的loader<code>npm i sass-loader node-sass -D</code> </li><li>修改配置文件：</li></ol><pre class=" language-javascript"><code class="language-javascript">    <span class="token comment" spellcheck="true">//在module下的rules增加如下代码</span>    <span class="token punctuation">{</span>         test<span class="token punctuation">:</span> <span class="token regex">/\.scss$/</span><span class="token punctuation">,</span>         use<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'style-loader'</span><span class="token punctuation">,</span> <span class="token string">'css-loader'</span><span class="token punctuation">,</span> <span class="token string">'sass-loader'</span><span class="token punctuation">]</span>     <span class="token punctuation">}</span></code></pre><h2 id="使用webpack处理css中的路径（图片等一系列）"><a href="#使用webpack处理css中的路径（图片等一系列）" class="headerlink" title="使用webpack处理css中的路径（图片等一系列）"></a>使用webpack处理css中的路径（图片等一系列）</h2><ol><li>下载需要的loader<code>npm i url-loader file-loader -D</code> </li><li>修改配置文件：</li></ol><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">//在module下的rules增加如下代码</span><span class="token punctuation">{</span> test<span class="token punctuation">:</span> <span class="token regex">/\.(png|jpg|gif)$/</span><span class="token punctuation">,</span> use<span class="token punctuation">:</span> <span class="token string">'url-loader'</span> <span class="token punctuation">}</span></code></pre><ol><li>默认会将图片转换成<code>base64</code>,可以通过<code>limit</code>设置进行base64编码的图片大小；只有小于指定字节（byte）的图片才会进行base64编码：</li></ol><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">//在module下的rules增加如下代码</span><span class="token punctuation">{</span> test<span class="token punctuation">:</span> <span class="token regex">/\.(png|jpg|gif)$/</span><span class="token punctuation">,</span> use<span class="token punctuation">:</span> <span class="token string">'url-loader?limit=43960'</span> <span class="token punctuation">}</span><span class="token punctuation">,</span></code></pre><h2 id="使用babel处理高级JS语法"><a href="#使用babel处理高级JS语法" class="headerlink" title="使用babel处理高级JS语法"></a>使用babel处理高级JS语法</h2><ol><li>安装需要的loader<code>npm i babel-core babel-loader babel-plugin-transform-runtime -D</code> </li><li>安装转换规则<code>npm i babel-preset-env babel-preset-stage-0 -D</code> </li><li>修改配置文件添加相关loader模块，<strong>一定要把node_modules文件夹添加到排除</strong>：</li></ol><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">//在module下的rules增加如下代码</span><span class="token punctuation">{</span>     test<span class="token punctuation">:</span> <span class="token regex">/\.js$/</span><span class="token punctuation">,</span>     use<span class="token punctuation">:</span> <span class="token string">'babel-loader'</span><span class="token punctuation">,</span>     <span class="token comment" spellcheck="true">//排除node_modules</span>    exclude<span class="token punctuation">:</span> <span class="token regex">/node_modules/</span> <span class="token punctuation">}</span></code></pre><ol><li>在项目根目录中添加babel的配置文件<code>.babelrc</code>文件，并修改这个配置文件如下：</li></ol><pre class=" language-javascript"><code class="language-javascript"><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//使用何种转换语法</span>    <span class="token string">"presets"</span><span class="token punctuation">:</span><span class="token punctuation">[</span><span class="token string">"env"</span><span class="token punctuation">,</span> <span class="token string">"stage-0"</span><span class="token punctuation">]</span><span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">//插件配置</span>    <span class="token string">"plugins"</span><span class="token punctuation">:</span><span class="token punctuation">[</span><span class="token string">"transform-runtime"</span><span class="token punctuation">]</span><span class="token punctuation">}</span></code></pre><blockquote><p><strong>注意：这里使用最新的转换语法babel-preset-env，你看网上很多都用babel-preset-es2015，建议你使用env,它包含了所有的ES相关的语法；</strong></p></blockquote><p>好了<code>webpack</code>的基本配置都说的差不多，不用去记，很多脚手架就能直接给你配好，比如<code>vue-cil</code>，不过如果怕忘欢迎<strong>收藏</strong>。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2019/07/17/web-kai-fa-de-kua-yu-wen-ti-xiang-jie/zong-jie-zhi-shi-dian/"/>
      <url>/2019/07/17/web-kai-fa-de-kua-yu-wen-ti-xiang-jie/zong-jie-zhi-shi-dian/</url>
      
        <content type="html"><![CDATA[<div id="write" class="is-node"><p><span>原型：</span></p><blockquote><p><span>函数创建后，自身就会产生一个prototype属性，这个属性指向函数的原型对象。在默认情况下，所有原型对象都会自动获得一个constructor（构造函数）属性，这个属性包含一个指向prototype属性所在函数的指针。当调用构造函数创建一个新实例后，该实例的内部将包含一个指针（内部属性），指向构造函数的原型对象。</span><span>原型链：由于</span><strong><span>proto</span></strong><span>是任何对象都有的属性，所以会形成一条</span><strong><span>proto</span></strong><span>连起来的链条，递归访问</span><strong><span>proto</span></strong><span>最终到头，并且值是null.</span></p><p><span>其基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。然后层层递进，就构成了实例与原型的链条，这就是所谓原型链的基本概念。</span></p></blockquote><p><span>闭包</span></p><blockquote><p><span>闭包属于一种特殊的作用域，能够读取其他函数内部变量的函数。它的定义可以理解为: 父函数被销毁 的情况下，返回出的子函数的</span><code>[[scope]]</code><span>中仍然保留着父级的单变量对象和作用域链，因此可以继续访问到父级的变量对象，这样的函数称为闭包。</span></p><p><span>闭包的缺点：滥用闭包函数会造成内存泄露，因为闭包中引用到的包裹函数中定义的变量都永远不会被释放。</span></p></blockquote><p><strong><span>闭包会产生一个很经典的问题:</span></strong></p><blockquote><p><span>多个子函数的</span><code>[[scope]]</code><span>都是同时指向父级，是完全共享的。因此当父级的变量对象被修改时，所有子函数都受到影响。</span></p></blockquote><p><span>••解决办法:**</span></p><ul><li><span>变量可以通过 函数参数的形式 传入，避免使用默认的</span><code>[[scope]]</code><span>向上查找</span></li><li><span>使用</span><code>setTimeout</code><span>包裹，通过第三个参数传入</span></li><li><span>使用 块级作用域，让变量成为自己上下文的属性，避免共享</span></li></ul><p><span>作用域：</span></p><blockquote><p><span>执行上下文中还包含作用域链。理解作用域之前，先介绍下作用域。作用域其实可理解为该上下文中声明的 变量和声明的作用范围。可分为 块级作用域 和 函数作用域</span></p></blockquote><p><span>作用域链：</span></p><blockquote><p><span>我们知道，我们可以在执行上下文中访问到父级甚至全局的变量，这便是作用域链的功劳。作用域链可以理解为一组对象列表，包含 父级和自身的变量对象，因此我们便能通过作用域链访问到父级里声明的变量或者函数。</span></p></blockquote><p><strong><span>由两部分组成:</span></strong></p><ul><li><code>[[scope]]</code><span>属性: 指向父级变量对象和作用域链，也就是包含了父级的</span><code>[[scope]]</code><span>和</span><code>AO</code></li><li><code>AO</code><span>: 自身活动对象</span></li></ul><blockquote><p><span>如此 </span><code>[[scopr]]</code><span>包含</span><code>[[scope]]</code><span>，便自上而下形成一条 链式作用域。</span></p></blockquote><p><strong><span>浅拷贝: 以赋值的形式拷贝引用对象，仍指向同一个地址，修改时原对象也会受到影响</span></strong></p><ul><li><code>Object.assign</code></li><li><span>展开运算符(</span><code>...</code><span>)</span></li></ul><p><strong><span>深拷贝: 完全拷贝一个新对象，修改时原对象不再受到任何影响</span></strong></p><ul><li><code>JSON.parse(JSON.stringify(obj))</code><span>: 性能最快</span></li><li><span>具有循环引用的对象时，报错</span></li><li><span>当值为函数、</span><code>undefined</code><span>、或</span><code>symbol</code><span>时，无法拷贝</span></li><li><span>递归进行逐一赋值</span></li></ul><p><strong><span>深拷贝: 完全拷贝一个新对象，修改时原对象不再受到任何影响</span></strong></p><ul><li><code>JSON.parse(JSON.stringify(obj))</code><span>: 性能最快</span></li><li><span>具有循环引用的对象时，报错</span></li><li><span>当值为函数、</span><code>undefined</code><span>、或</span><code>symbol</code><span>时，无法拷贝</span></li><li><span>递归进行逐一赋值</span></li></ul><h1><a name="vue:" class="md-header-anchor"></a><span>Vue:</span></h1><h3><a name="nexttick" class="md-header-anchor"></a><span>nextTick</span></h3><blockquote><p><span>在下次</span><code>dom</code><span>更新循环结束之后执行延迟回调，可用于获取更新后的</span><code>dom</code><span>状态</span></p></blockquote><h3><a name="vue-router" class="md-header-anchor"></a><span>vue-router</span></h3><p><strong><span>mode</span></strong></p><ul><li><code>hash</code><span></span></li><li><code>history</code></li></ul><p><span>Vue为什么要使用Virtual DOM?</span></p><ul><li><span>重要的原因是为了解耦 </span><code>HTML</code><span>依赖，这带来两个非常重要的好处是：</span></li></ul><blockquote><ul><li><span>不再依赖 </span><code>HTML</code><span> 解析器进行模版解析，可以进行更多的 </span><code>AOT</code><span> 工作提高运行时效率：通过模版 </span><code>AOT</code><span> 编译，</span><code>Vue</code><span> 的运行时体积可以进一步压缩，运行时效率可以进一步提升；</span></li><li><span>可以渲染到 </span><code>DOM</code><span> 以外的平台，实现 </span><code>SSR</code><span>、同构渲染这些高级特性，</span><code>Weex</code><span>等框架应用的就是这一特性。更重要的是它使得 </span><code>Vue</code><span> 具备了现代框架应有的高级特性。</span></li></ul></blockquote><h3><a name="vue-%E5%92%8C-react-%E5%8C%BA%E5%88%AB" class="md-header-anchor"></a><span>vue 和 react 区别</span></h3><ul><li><span>相同点：都支持 </span><code>ssr</code><span>，都有 </span><code>vdom</code><span>，组件化开发，实现 </span><code>webComponents</code><span> 规范，数据驱动等</span></li><li><span>不同点：</span></li><li><code>vue</code><span> 是双向数据流（当然为了实现单数据流方便管理组件状态，</span><code>vuex</code><span> 便出现了），</span></li><li><code>react</code><span> 是单向数据流。</span></li><li><code>vue</code><span>的 </span><code>vdom</code><span> 是追踪每个组件的依赖关系，不会渲染整个组件树，</span></li><li><code>react</code><span>每当应该状态被改变时，全部子组件都会 </span><code>re-render</code></li></ul><h4><a name="%E4%BB%80%E4%B9%88%E6%98%AF%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93" class="md-header-anchor"></a><span>什么是服务端渲染</span></h4><p><span>简单理解是将组件或页面通过服务器生成html字符串，再发送到浏览器，最后将静态标记"混合"为客户端上完全交互的应用程序</span></p><h4><a name="%E4%BD%BF%E7%94%A8ssr%E7%9A%84%E5%A5%BD%E5%A4%84%E4%B8%8E%E5%9D%8F%E5%A4%84" class="md-header-anchor"></a><span>使用SSR的好处与坏处</span></h4><p><span>1、更利于SEO优化</span></p><p><span>2、更利于首屏渲染</span></p><p><span>3、使用服务端请求首屏数据会比客户端请求更快，因为服务端在内网进行请求，数据响应速度快。客户端在不同网络环境进行数据请求，且外网http请求开销大，导致时间差。 </span></p><p><span>局限性：</span></p><p><span>1、服务端压力较大</span></p><p><span>本来是通过客户端完成渲染，现在统一到服务端node服务去做。尤其是高并发访问的情况，会大量占用服务端CPU资源；</span></p><p><span>2、开发条件受限</span></p><p><span>在服务端渲染中，只会执行到componentDidMount之前的生命周期钩子</span></p><p><span>3、学习成本较高</span></p><p><span>除了对webpack、React要熟悉，还需要掌握node、Koa2等相关技术。相对于客户端渲染，项目构建、部署过程更加复杂。</span></p><h2><a name="var%E3%80%81let-%E5%8F%8A-const-%E5%8C%BA%E5%88%AB" class="md-header-anchor"></a><span>var、let 及 const 区别</span></h2><ul><li><span>函数提升优先于变量提升，函数提升会把整个函数挪到作用域顶部，变量提升只会把声明挪到作用域顶部</span></li><li><code>var</code><span> 存在提升，我们能在声明之前使用。</span><code>let</code><span>、</span><code>const</code><span> 因为暂时性死区的原因，不能在声明前使用</span></li><li><code>var</code><span> 在全局作用域下声明变量会导致变量挂载在 </span><code>window</code><span>上，其他两者不会</span></li><li><code>let</code><span> 和 </span><code>const</code><span> 作用基本一致，但是后者声明的变量不能再次赋值</span></li></ul><p><span>继承方式：</span></p><h3><a name="%E5%8E%9F%E5%9E%8B%E7%BB%A7%E6%89%BF" class="md-header-anchor"></a><span>原型继承</span></h3><p><span>组合继承</span></p><p><span>子类的构造函数中通过 </span><code>Parent.call(this)</code><span> 继承父类的属性，然后改变子类的原型为 </span><code>new Parent()</code><span> 来继承父类的函数。</span></p><ul><li><span>这种继承方式优点在于构造函数可以传参，不会与父类引用属性共享，可以复用父类的函数，但是也存在一个缺点就是在继承父类函数的时候调用了父类构造函数，导致子类的原型上多了不需要的父类属性，存在内存上的浪费</span></li></ul><p><span>寄生组合继承</span></p><p><span>的核心就是将父类的原型赋值给了子类，并且将构造函数设置为子类，这样既解决了无用的父类属性问题，还能正确的找到子类的构造函数。</span></p><p><strong><span>Class 继承</span></strong></p><p><code>class</code><span> 实现继承的核心在于使用 </span><code>extends</code><span> 表明继承自哪个父类，并且在子类构造函数中必须调用 </span><code>super</code><span>，因为这段代码可以看成 </span><code>Parent.call(this, value)</code><span>。</span></p><h3><a name="hash%E6%A8%A1%E5%BC%8F%E4%B8%8Ehistory%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB" class="md-header-anchor"></a><span>Hash模式与History模式的区别</span></h3><p><span>Dva的基本使用：</span></p><p><span>webpack的基本使用：</span></p><p><span>Less和Sass的特点及区别：</span></p><p><span>Ajax、fetch、axios的区别：</span></p><p> </p></div><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>总结知识点</title>
      <link href="/2019/07/15/zong-jie-zhi-shi-dian/"/>
      <url>/2019/07/15/zong-jie-zhi-shi-dian/</url>
      
        <content type="html"><![CDATA[<p>原型：</p><blockquote><p>每一个对象都有<strong>proto</strong>即原型。<br>原型链：由于<strong>proto</strong>是任何对象都有的属性，所以会形成一条<strong>proto</strong>连起来的链条，递归访问<strong>proto</strong>最终到头，并且值是null.</p></blockquote><p>闭包</p><blockquote><p>闭包属于一种特殊的作用域，能够读取其他函数内部变量的函数。它的定义可以理解为: 父函数被销毁 的情况下，返回出的子函数的<code>[[scope]]</code>中仍然保留着父级的单变量对象和作用域链，因此可以继续访问到父级的变量对象，这样的函数称为闭包。</p><p>闭包的缺点：滥用闭包函数会造成内存泄露，因为闭包中引用到的包裹函数中定义的变量都永远不会被释放。</p></blockquote><p><strong>闭包会产生一个很经典的问题:</strong></p><blockquote><p>多个子函数的<code>[[scope]]</code>都是同时指向父级，是完全共享的。因此当父级的变量对象被修改时，所有子函数都受到影响。</p></blockquote><p>••解决办法:**</p><ul><li>变量可以通过 函数参数的形式 传入，避免使用默认的<code>[[scope]]</code>向上查找</li><li>使用<code>setTimeout</code>包裹，通过第三个参数传入</li><li>使用 块级作用域，让变量成为自己上下文的属性，避免共享</li></ul><p>作用域：</p><blockquote><p>执行上下文中还包含作用域链。理解作用域之前，先介绍下作用域。作用域其实可理解为该上下文中声明的 变量和声明的作用范围。可分为 块级作用域 和 函数作用域</p></blockquote><p>作用域链：</p><blockquote><p>我们知道，我们可以在执行上下文中访问到父级甚至全局的变量，这便是作用域链的功劳。作用域链可以理解为一组对象列表，包含 父级和自身的变量对象，因此我们便能通过作用域链访问到父级里声明的变量或者函数。</p></blockquote><p><strong>由两部分组成:</strong></p><ul><li><code>[[scope]]</code>属性: 指向父级变量对象和作用域链，也就是包含了父级的<code>[[scope]]</code>和<code>AO</code></li><li><code>AO</code>: 自身活动对象</li></ul><blockquote><p>如此 <code>[[scopr]]</code>包含<code>[[scope]]</code>，便自上而下形成一条 链式作用域。</p></blockquote><p><strong>浅拷贝: 以赋值的形式拷贝引用对象，仍指向同一个地址，修改时原对象也会受到影响</strong></p><ul><li><code>Object.assign</code></li><li>展开运算符(<code>...</code>)</li></ul><p><strong>深拷贝: 完全拷贝一个新对象，修改时原对象不再受到任何影响</strong></p><ul><li><code>JSON.parse(JSON.stringify(obj))</code>: 性能最快</li><li>具有循环引用的对象时，报错</li><li>当值为函数、<code>undefined</code>、或<code>symbol</code>时，无法拷贝</li><li>递归进行逐一赋值</li></ul><p><strong>深拷贝: 完全拷贝一个新对象，修改时原对象不再受到任何影响</strong></p><ul><li><code>JSON.parse(JSON.stringify(obj))</code>: 性能最快</li><li>具有循环引用的对象时，报错</li><li>当值为函数、<code>undefined</code>、或<code>symbol</code>时，无法拷贝</li><li>递归进行逐一赋值</li></ul><h1 id="Vue"><a href="#Vue" class="headerlink" title="Vue:"></a>Vue:</h1><h3 id="nextTick"><a href="#nextTick" class="headerlink" title="nextTick"></a>nextTick</h3><blockquote><p>在下次<code>dom</code>更新循环结束之后执行延迟回调，可用于获取更新后的<code>dom</code>状态</p></blockquote><h3 id="vue-router"><a href="#vue-router" class="headerlink" title="vue-router"></a>vue-router</h3><p><strong>mode</strong></p><ul><li><code>hash</code>            </li><li><code>history</code></li></ul><p>Vue为什么要使用Virtual DOM?</p><ul><li>重要的原因是为了解耦 <code>HTML</code>依赖，这带来两个非常重要的好处是：</li></ul><blockquote><ul><li>不再依赖 <code>HTML</code> 解析器进行模版解析，可以进行更多的 <code>AOT</code> 工作提高运行时效率：通过模版 <code>AOT</code> 编译，<code>Vue</code> 的运行时体积可以进一步压缩，运行时效率可以进一步提升；</li><li>可以渲染到 <code>DOM</code> 以外的平台，实现 <code>SSR</code>、同构渲染这些高级特性，<code>Weex</code>等框架应用的就是这一特性。更重要的是它使得 <code>Vue</code> 具备了现代框架应有的高级特性。</li></ul></blockquote><h3 id="vue-和-react-区别"><a href="#vue-和-react-区别" class="headerlink" title="vue 和 react 区别"></a>vue 和 react 区别</h3><ul><li>相同点：都支持 <code>ssr</code>，都有 <code>vdom</code>，组件化开发，实现 <code>webComponents</code> 规范，数据驱动等</li><li>不同点：</li><li><code>vue</code> 是双向数据流（当然为了实现单数据流方便管理组件状态，<code>vuex</code> 便出现了），</li><li><code>react</code> 是单向数据流。</li><li><code>vue</code>的 <code>vdom</code> 是追踪每个组件的依赖关系，不会渲染整个组件树，</li><li><code>react</code>每当应该状态被改变时，全部子组件都会 <code>re-render</code></li></ul><h4 id="什么是服务端渲染"><a href="#什么是服务端渲染" class="headerlink" title="什么是服务端渲染"></a>什么是服务端渲染</h4><p>简单理解是将组件或页面通过服务器生成html字符串，再发送到浏览器，最后将静态标记”混合”为客户端上完全交互的应用程序</p><h4 id="使用SSR的好处与坏处"><a href="#使用SSR的好处与坏处" class="headerlink" title="使用SSR的好处与坏处"></a>使用SSR的好处与坏处</h4><p>1、更利于SEO优化</p><p>2、更利于首屏渲染</p><p>3、使用服务端请求首屏数据会比客户端请求更快，因为服务端在内网进行请求，数据响应速度快。客户端在不同网络环境进行数据请求，且外网http请求开销大，导致时间差。 </p><p>局限性：</p><p>1、服务端压力较大</p><p>本来是通过客户端完成渲染，现在统一到服务端node服务去做。尤其是高并发访问的情况，会大量占用服务端CPU资源；</p><p>2、开发条件受限</p><p>在服务端渲染中，只会执行到componentDidMount之前的生命周期钩子</p><p>3、学习成本较高</p><p>除了对webpack、React要熟悉，还需要掌握node、Koa2等相关技术。相对于客户端渲染，项目构建、部署过程更加复杂。</p><h2 id="var、let-及-const-区别"><a href="#var、let-及-const-区别" class="headerlink" title="var、let 及 const 区别"></a>var、let 及 const 区别</h2><ul><li>函数提升优先于变量提升，函数提升会把整个函数挪到作用域顶部，变量提升只会把声明挪到作用域顶部</li><li><code>var</code> 存在提升，我们能在声明之前使用。<code>let</code>、<code>const</code> 因为暂时性死区的原因，不能在声明前使用</li><li><code>var</code> 在全局作用域下声明变量会导致变量挂载在 <code>window</code>上，其他两者不会</li><li><code>let</code> 和 <code>const</code> 作用基本一致，但是后者声明的变量不能再次赋值</li></ul><p>继承方式：</p><h3 id="原型继承"><a href="#原型继承" class="headerlink" title="原型继承"></a>原型继承</h3><p>组合继承</p><p>子类的构造函数中通过 <code>Parent.call(this)</code> 继承父类的属性，然后改变子类的原型为 <code>new Parent()</code> 来继承父类的函数。</p><ul><li>这种继承方式优点在于构造函数可以传参，不会与父类引用属性共享，可以复用父类的函数，但是也存在一个缺点就是在继承父类函数的时候调用了父类构造函数，导致子类的原型上多了不需要的父类属性，存在内存上的浪费</li></ul><p>寄生组合继承</p><p>的核心就是将父类的原型赋值给了子类，并且将构造函数设置为子类，这样既解决了无用的父类属性问题，还能正确的找到子类的构造函数。</p><p><strong>Class 继承</strong></p><p><code>class</code> 实现继承的核心在于使用 <code>extends</code> 表明继承自哪个父类，并且在子类构造函数中必须调用 <code>super</code>，因为这段代码可以看成 <code>Parent.call(this, value)</code>。</p><h3 id="Hash模式与History模式的区别"><a href="#Hash模式与History模式的区别" class="headerlink" title="Hash模式与History模式的区别"></a>Hash模式与History模式的区别</h3><p>Dva的基本使用：</p><p>webpack的基本使用：</p><p>Less和Sass的特点及区别：</p><p>Ajax、fetch、axios的区别：</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>vue+node实现拖拽上传图片</title>
      <link href="/2019/04/28/vue-node-shi-xian-tuo-zhuai-shang-chuan-tu-pian/"/>
      <url>/2019/04/28/vue-node-shi-xian-tuo-zhuai-shang-chuan-tu-pian/</url>
      
        <content type="html"><![CDATA[<h3 id="一、知识点"><a href="#一、知识点" class="headerlink" title="一、知识点"></a>一、知识点</h3><p>实现拖拽上传需要用到的知识点如下：</p><p><strong>前端</strong><br> <code>拖拽事件</code><br> <code>dataTransfer</code><br> <code>FileReader</code><br> <code>FormData</code><br> <code>progress</code></p><p><strong>后端</strong><br> <code>multer</code><br> <code>fs.renameSync</code></p><h4 id="1-H5拖拽事件"><a href="#1-H5拖拽事件" class="headerlink" title="1.H5拖拽事件"></a>1.H5拖拽事件</h4><p>我们拖动图片放到一个div上时，下列事件会依次发生：</p><ul><li>dragenter</li><li>dragover</li><li>dragleave或drop</li></ul><p>只要图片被拖动到div上，就会触发<strong>dragenter</strong>事件，类似于mouseover事件。<br> 紧接着是<strong>dragover</strong>事件，而且只要图片在div内移动，就会不停的触发。<br> 如果拖出了div的范围，dragover事件不再发生，但会触发<strong>dragleave</strong>事件。<br> 如果你拖着图片在div上松手了，就会触发<strong>drop</strong>事件。</p><h4 id="2-dataTransfer对象"><a href="#2-dataTransfer对象" class="headerlink" title="2.dataTransfer对象"></a>2.dataTransfer对象</h4><p>只有简单的拖放而没有数据变化是莫得用的。我们拖个图片进来的目的是啥？当然是为了获得图片数据，这样才能然后传到服务器上去。于是有了<strong>dataTransfer</strong>对象，它是事件对象的一个属性，用于从被拖动元素向放置目标传递字符串格式的数据。我们要完成拖拽上传图片就得靠这个对象，因为它是事件对象的属性，所以我们只能在事件处理程序中使用，参考以下代码：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">//在drop事件中使用dataTransfer对象</span> onDrop<span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"松手"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">var</span> dt <span class="token operator">=</span> e<span class="token punctuation">.</span>dataTransfer<span class="token punctuation">;</span>          <span class="token punctuation">}</span></code></pre><h4 id="3-FormData"><a href="#3-FormData" class="headerlink" title="3.FormData"></a>3.FormData</h4><p><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FAPI%2FFormData%2FUsing_FormData_Objects" target="_blank" rel="noopener">MND文档</a></p><p>具体的用法还是得阅读MDN文档好，以下是本菜鸡读了文档后对FormData的理解：</p><p>首先明确FomeData是一个对象，由键值对组成，有个append（）方法增加键值，我们可以append字符、数值或是文件</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> formData <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FormData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>formData<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">,</span> <span class="token string">"Ciger"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>formData<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"phone"</span><span class="token punctuation">,</span> <span class="token number">123456</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//数字123456会被立即转换成字符串 "123456"</span><span class="token comment" spellcheck="true">// HTML 文件类型input，由用户选择</span>formData<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"userfile"</span><span class="token punctuation">,</span> fileInputElement<span class="token punctuation">.</span>files<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>append后，我们可通过get()和set()操作对象的值</p><pre><code>formData.get('name')  // 获取值-> CigerformData.set('name','Ciger2') //重置值-> Ciger2</code></pre><p>知道如何使用这个对象了，最关键的就是它有什么用？<br> formData的作用有两个：</p><ul><li>用于发送表单数据，也可独立于表单使用</li><li>上传文件</li></ul><p>独立于表单使用有点抽象，我们来看代码。</p><pre class=" language-javascript"><form  id="myForm"><code class="language-javascript"><form  id="myForm">  <input type="email" name="userid" placeholder="email"/>  <input type="text" name="content" />  <input type="submit" value="Stash the file!" /></form></code></pre><p>代码里是一个form表单，有两个input输入框加一个提交按钮。通常来说，我们提交数据时要先获取到两个input框的数据，拼接在一起，然后通过ajax发送。<br> 有了FormData对象，两行代码就可以实现form对象数据的拼接</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> form <span class="token operator">=</span>  <span class="token keyword">var</span> form<span class="token operator">=</span>document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">"#myForm"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token keyword">var</span> data <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FormData</span><span class="token punctuation">(</span>form<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>上述代码的data都是form表单里的填的，独立于表单使用即代表我们可以不需要html元素，直接生成数据，然后发送给后端。</p><p>来看下面的上传文件代码</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> file <span class="token operator">=</span> e<span class="token punctuation">.</span>dataTransfer<span class="token punctuation">.</span>files<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>  <span class="token comment" spellcheck="true">//通过dataTransfer获取拖拽过来的文件</span><span class="token keyword">var</span> formData <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FormData</span><span class="token punctuation">(</span><span class="token punctuation">)</span>formData<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">'file'</span><span class="token punctuation">,</span>file<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//ajax发送formData</span><span class="token operator">...</span>xhr<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span>formData<span class="token punctuation">)</span></code></pre><p><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FAPI%2FFileReader" target="_blank" rel="noopener">MDN文档</a></p><p>FileReader对象是用来读取文件的，我们可以通过<code>new FileReader(file)</code>创建一个FileReader对象，file参数代表要读取的文件，可以来自用户在一个<code><nput></code>元素上选择文件后返回的FileList对象，也可以是拖放操作生成的DataTransfer对象</p><p>FileReader有如下事件：</p><ul><li>onabort</li><li>onerror</li><li>onload</li><li>onloadstart</li><li>onloadend</li><li>onprogress</li></ul><p>我们可以通过这些事件实现图片的预览，代码如下：</p><pre class=" language-javascript"><code class="language-javascript"> <span class="token keyword">var</span> fr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileReader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> fr<span class="token punctuation">.</span><span class="token function">readAsDataURL</span><span class="token punctuation">(</span>file<span class="token punctuation">)</span><span class="token punctuation">;</span>  fr<span class="token punctuation">.</span>onload <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>result<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//这里的this指向是FileReader对象！！！</span><span class="token comment" spellcheck="true">//这里的this指向是FileReader对象！！！</span><span class="token comment" spellcheck="true">//这里的this指向是FileReader对象！！！</span><span class="token comment" spellcheck="true">//将图片的地址src设置为this.result即可</span> <span class="token punctuation">}</span></code></pre><p><strong>注意！！读取后的结果会存在onload事件中的this.result中！</strong></p><h4 id="5-进度事件（Progress）"><a href="#5-进度事件（Progress）" class="headerlink" title="5.进度事件（Progress）"></a>5.进度事件（Progress）</h4><p>progress事件是针对XHR操作的，会在浏览器接受新数据期间周期性的触发，而onprogress事件处理程序会接收到一个events对象，其target属性是XHR对象，但包含了三个额外的属性</p><ul><li>lengthComputable 进度信息是否可用</li><li>position 已接收到的字节数</li><li>totalSize 根据Content-Length响应头部确定的预期字节数</li></ul><p>有了这些信息，我们就可以为用户创建一个上传进度条</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> xhr <span class="token operator">=</span> <span class="token function">createXHR</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>xhr<span class="token punctuation">.</span>onload <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>xhr<span class="token punctuation">.</span>status <span class="token operator">>=</span> <span class="token number">200</span> <span class="token operator">&amp;&amp;</span> xhr<span class="token punctuation">.</span>status <span class="token operator">&lt;</span> <span class="token number">300</span><span class="token punctuation">)</span> <span class="token operator">||</span> xhr<span class="token punctuation">.</span>status <span class="token operator">==</span> <span class="token number">304</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">alert</span><span class="token punctuation">(</span>xhr<span class="token punctuation">.</span>responseText<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">"Request was unsuccessful: "</span> <span class="token operator">+</span> xhr<span class="token punctuation">.</span>status<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//post一般用来获取上传进度</span>xhr<span class="token punctuation">.</span>upload<span class="token punctuation">.</span>onprogress <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>lengthComputable<span class="token punctuation">)</span> <span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>loaded <span class="token operator">/</span> e<span class="token punctuation">.</span>total <span class="token operator">*</span> <span class="token number">100</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="二、前端代码"><a href="#二、前端代码" class="headerlink" title="二、前端代码"></a>二、前端代码</h3><pre class=" language-html"><code class="language-html"><span class="token doctype">&lt;!DOCTYPE html></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span>      <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>viewport<span class="token punctuation">"</span></span>      <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>width<span class="token punctuation">=</span>device-width, user-scalable<span class="token punctuation">=</span>no, initial-scale<span class="token punctuation">=</span>1.0, maximum-scale<span class="token punctuation">=</span>1.0, minimum-scale<span class="token punctuation">=</span>1.0<span class="token punctuation">"</span></span>    <span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>X-UA-Compatible<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>ie<span class="token punctuation">=</span>edge<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span>      <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>https://cdn.bootcss.com/bootstrap/4.0.0/css/bootstrap.min.css<span class="token punctuation">"</span></span>      <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>stylesheet<span class="token punctuation">"</span></span>    <span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>https://cdn.bootcss.com/vue/2.5.13/vue.min.js<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script language-javascript"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">></span></span><span class="token style language-css">      <span class="token selector"><span class="token class">.dropbox</span> </span><span class="token punctuation">{</span>        <span class="token property">border</span><span class="token punctuation">:</span> <span class="token number">0.25</span>rem dashed <span class="token hexcode">#ddd</span><span class="token punctuation">;</span>        <span class="token property">min-height</span><span class="token punctuation">:</span> <span class="token number">8</span>rem<span class="token punctuation">;</span>        <span class="token property">display</span><span class="token punctuation">:</span> flex<span class="token punctuation">;</span>        <span class="token property">justify-content</span><span class="token punctuation">:</span> flex-start<span class="token punctuation">;</span>        <span class="token property">align-items</span><span class="token punctuation">:</span> center<span class="token punctuation">;</span>        <span class="token property">flex-wrap</span><span class="token punctuation">:</span> wrap<span class="token punctuation">;</span>      <span class="token punctuation">}</span>    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>Document<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>app<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>m-5<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dropbox p-3<span class="token punctuation">"</span></span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dropbox<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h5</span>          <span class="token attr-name">v-if</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>files.length<span class="token punctuation">=</span><span class="token punctuation">=</span><span class="token punctuation">=</span>0<span class="token punctuation">"</span></span>          <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text-center<span class="token punctuation">"</span></span><span class="token style-attr language-css"><span class="token attr-name">          <span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value"><span class="token property">width</span><span class="token punctuation">:</span><span class="token number">100%</span><span class="token punctuation">;</span><span class="token property">color</span><span class="token punctuation">:</span><span class="token hexcode">#aaa</span><span class="token punctuation">;</span></span><span class="token punctuation">"</span></span>        <span class="token punctuation">></span></span>          将文件拖到这里        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h5</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span>          <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>border m-2 d-inline-block p-4<span class="token punctuation">"</span></span><span class="token style-attr language-css"><span class="token attr-name">          <span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value"><span class="token property">width</span><span class="token punctuation">:</span><span class="token number">15</span>rem<span class="token punctuation">;</span><span class="token property">flex</span><span class="token punctuation">:</span>none<span class="token punctuation">;</span></span><span class="token punctuation">"</span></span>          <span class="token attr-name">v-for</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>(file,index) in files<span class="token punctuation">"</span></span>          <span class="token attr-name">:key</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>index<span class="token punctuation">"</span></span>        <span class="token punctuation">></span></span>          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h5</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>mt-0<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>{{ file.name }}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h5</span><span class="token punctuation">></span></span>          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span>            <span class="token attr-name">:src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>file.src<span class="token punctuation">"</span></span><span class="token style-attr language-css"><span class="token attr-name">            <span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value"><span class="token property">width</span><span class="token punctuation">:</span>auto<span class="token punctuation">;</span><span class="token property">height</span><span class="token punctuation">:</span>auto<span class="token punctuation">;</span><span class="token property">max-width</span><span class="token punctuation">:</span> <span class="token number">100%</span><span class="token punctuation">;</span><span class="token property">max-height</span><span class="token punctuation">:</span> <span class="token number">100%</span><span class="token punctuation">;</span></span><span class="token punctuation">"</span></span>          <span class="token punctuation">/></span></span>          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>progress<span class="token punctuation">"</span></span> <span class="token attr-name">v-if</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>file.showPercentage<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span>              <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>progress-bar progress-bar-striped<span class="token punctuation">"</span></span>              <span class="token attr-name">:</span><span class="token style-attr language-css"><span class="token attr-name"><span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value"><span class="token punctuation">{</span> <span class="token property">width</span><span class="token punctuation">:</span> file<span class="token number">.</span>uploadPercentage+<span class="token string">'%'</span> <span class="token punctuation">}</span></span><span class="token punctuation">"</span></span>            <span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script language-javascript">      <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>        el<span class="token punctuation">:</span> <span class="token string">"#app"</span><span class="token punctuation">,</span>        data<span class="token punctuation">:</span> <span class="token punctuation">{</span>          files<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>        methods<span class="token punctuation">:</span> <span class="token punctuation">{</span>          uploadFile<span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span>file<span class="token punctuation">,</span> url<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>              <span class="token keyword">var</span> fr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileReader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token keyword">var</span> that <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>              <span class="token keyword">var</span> item <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>              fr<span class="token punctuation">.</span><span class="token function">readAsDataURL</span><span class="token punctuation">(</span>file<span class="token punctuation">)</span><span class="token punctuation">;</span>              fr<span class="token punctuation">.</span>onload <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                item <span class="token operator">=</span> <span class="token punctuation">{</span>                  src<span class="token punctuation">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>result<span class="token punctuation">,</span>                  name<span class="token punctuation">:</span> file<span class="token punctuation">.</span>name<span class="token punctuation">,</span>                  uploadPercentage<span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">,</span>                  showPercentage<span class="token punctuation">:</span> <span class="token boolean">true</span>                <span class="token punctuation">}</span><span class="token punctuation">;</span>                that<span class="token punctuation">.</span>files<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">var</span> fd <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FormData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                fd<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"file"</span><span class="token punctuation">,</span> file<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">var</span> xhr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">XMLHttpRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                xhr<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">"POST"</span><span class="token punctuation">,</span> url<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                xhr<span class="token punctuation">.</span>upload<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span>                  <span class="token string">"progress"</span><span class="token punctuation">,</span>                  <span class="token keyword">function</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>loaded <span class="token operator">==</span> e<span class="token punctuation">.</span>total<span class="token punctuation">)</span> <span class="token punctuation">{</span>                      item<span class="token punctuation">.</span>uploadPercentage <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">round</span><span class="token punctuation">(</span>                        <span class="token punctuation">(</span>e<span class="token punctuation">.</span>loaded <span class="token operator">*</span> <span class="token number">100</span><span class="token punctuation">)</span> <span class="token operator">/</span> e<span class="token punctuation">.</span>total                      <span class="token punctuation">)</span><span class="token punctuation">;</span>                      <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>                        item<span class="token punctuation">.</span>showPercentage <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                      <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                      item<span class="token punctuation">.</span>uploadPercentage <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">round</span><span class="token punctuation">(</span>                        <span class="token punctuation">(</span>e<span class="token punctuation">.</span>loaded <span class="token operator">*</span> <span class="token number">100</span><span class="token punctuation">)</span> <span class="token operator">/</span> e<span class="token punctuation">.</span>total                      <span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                  <span class="token punctuation">}</span><span class="token punctuation">,</span>                  <span class="token boolean">false</span>                <span class="token punctuation">)</span><span class="token punctuation">;</span>                xhr<span class="token punctuation">.</span>onload <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                  <span class="token comment" spellcheck="true">//   alert("上传完成！");</span>                <span class="token punctuation">}</span><span class="token punctuation">;</span>                xhr<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token punctuation">}</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token punctuation">}</span><span class="token punctuation">,</span>          onDrag<span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">stopPropagation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            e<span class="token punctuation">.</span><span class="token function">preventDefault</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"进入"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>$refs<span class="token punctuation">.</span>dropbox<span class="token punctuation">.</span>style <span class="token operator">=</span> <span class="token string">"border:0.25rem dashed #007bff;"</span><span class="token punctuation">;</span>          <span class="token punctuation">}</span><span class="token punctuation">,</span>          onDragLeave<span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">stopPropagation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            e<span class="token punctuation">.</span><span class="token function">preventDefault</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"离开"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>$refs<span class="token punctuation">.</span>dropbox<span class="token punctuation">.</span>style <span class="token operator">=</span> <span class="token string">"border:0.25rem dashed #ddd;"</span><span class="token punctuation">;</span>          <span class="token punctuation">}</span><span class="token punctuation">,</span>          onDrop<span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">stopPropagation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            e<span class="token punctuation">.</span><span class="token function">preventDefault</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"松手"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">var</span> url <span class="token operator">=</span> <span class="token string">"http://127.0.0.1:3000/upload-multiply"</span><span class="token punctuation">;</span>            <span class="token keyword">var</span> dt <span class="token operator">=</span> e<span class="token punctuation">.</span>dataTransfer<span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">!==</span> dt<span class="token punctuation">.</span>files<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>              <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">uploadFile</span><span class="token punctuation">(</span>dt<span class="token punctuation">.</span>files<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> url<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>          <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>        mounted<span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token keyword">var</span> dropbox <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">".dropbox"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          dropbox<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">"dragenter"</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>onDrag<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          dropbox<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">"dragover"</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>onDrag<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          dropbox<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">"dragleave"</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>onDragLeave<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          dropbox<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">"drop"</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>onDrop<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span></code></pre><h3 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h3><ol><li>HTML部分有个<strong>ref=”dropbox”</strong>的div，这个就是我们的拖拽区域</li></ol><pre class=" language-html"><div id="app"><code class="language-html"><div id="app">  <div class="dropbox p-3" ref="dropbox">...</div>  ...</div></code></pre><ol><li>JS部分，mounted的时候,对dropbox添加拖拽事件的监听</li></ol><pre class=" language-javascript"><code class="language-javascript"> mounted<span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token keyword">var</span> dropbox <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">".dropbox"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          dropbox<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">"dragenter"</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>onDrag<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          dropbox<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">"dragover"</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>onDrag<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          dropbox<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">"dragleave"</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>onDragLeave<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          dropbox<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">"drop"</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>onDrop<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span></code></pre><p>3.methods中实现这几个事件函数</p><pre class=" language-javascript"><code class="language-javascript"><span class="token function">upload</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment" spellcheck="true">//上传文件方法</span><span class="token function">onDrag</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token function">onDragLeave</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token function">onDrop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//具体实现看上述代码</span></code></pre><h3 id="三、后端代码"><a href="#三、后端代码" class="headerlink" title="三、后端代码"></a>三、后端代码</h3><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> fs <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"fs"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> express <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"express"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> multer <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"multer"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> app <span class="token operator">=</span> <span class="token function">express</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> upload <span class="token operator">=</span> <span class="token function">multer</span><span class="token punctuation">(</span><span class="token punctuation">{</span> dest<span class="token punctuation">:</span> <span class="token string">"upload/"</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//设置跨域访问</span>app<span class="token punctuation">.</span><span class="token function">all</span><span class="token punctuation">(</span><span class="token string">"*"</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span>req<span class="token punctuation">,</span> res<span class="token punctuation">,</span> next<span class="token punctuation">)</span> <span class="token punctuation">{</span>  res<span class="token punctuation">.</span><span class="token function">header</span><span class="token punctuation">(</span><span class="token string">"Access-Control-Allow-Origin"</span><span class="token punctuation">,</span> <span class="token string">"*"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  res<span class="token punctuation">.</span><span class="token function">header</span><span class="token punctuation">(</span><span class="token string">"Access-Control-Allow-Headers"</span><span class="token punctuation">,</span> <span class="token string">"X-Requested-With"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  res<span class="token punctuation">.</span><span class="token function">header</span><span class="token punctuation">(</span><span class="token string">"Access-Control-Allow-Methods"</span><span class="token punctuation">,</span> <span class="token string">"PUT,POST,GET,DELETE,OPTIONS"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  res<span class="token punctuation">.</span><span class="token function">header</span><span class="token punctuation">(</span><span class="token string">"X-Powered-By"</span><span class="token punctuation">,</span> <span class="token string">" 3.2.1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// res.header("Content-Type", "application/json;charset=utf-8");</span>  <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 多图上传</span>app<span class="token punctuation">.</span><span class="token function">post</span><span class="token punctuation">(</span><span class="token string">"/upload-multiply"</span><span class="token punctuation">,</span> upload<span class="token punctuation">.</span><span class="token function">array</span><span class="token punctuation">(</span><span class="token string">"file"</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span>req<span class="token punctuation">,</span> res<span class="token punctuation">,</span> next<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">var</span> files <span class="token operator">=</span> req<span class="token punctuation">.</span>files<span class="token punctuation">;</span>  <span class="token keyword">var</span> fileName <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>files<span class="token punctuation">.</span>length <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    files<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>item <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>      fileName <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"-"</span> <span class="token operator">+</span> item<span class="token punctuation">.</span>originalname<span class="token punctuation">;</span>      fs<span class="token punctuation">.</span><span class="token function">renameSync</span><span class="token punctuation">(</span>item<span class="token punctuation">.</span>path<span class="token punctuation">,</span> __dirname <span class="token operator">+</span> <span class="token string">"\\upload"</span> <span class="token operator">+</span> <span class="token string">"\\"</span> <span class="token operator">+</span> fileName<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    res<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token punctuation">{</span> code<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span> url<span class="token punctuation">:</span> <span class="token string">"127.0.0.1:3000/upload/"</span> <span class="token operator">+</span> fileName <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>    res<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token punctuation">{</span> code<span class="token punctuation">:</span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>app<span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>后端需要<code>npm install express multer</code><br> <strong>运行前要先创建upload文件夹用于存放文件</strong></p><h3 id="四、源码与总结"><a href="#四、源码与总结" class="headerlink" title="四、源码与总结"></a>四、源码与总结</h3><p>源码地址：<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2FC-Utopia%2Fpratice-project.git" target="_blank" rel="noopener">https://github.com/C-Utopia/pratice-project.git</a></p><p>之前一直对H5的拖拽事件和文件上传迷迷糊糊，所以做了这个小练习。</p><p>遇到没做过的东西，首先上网搜索，例如我想实现拖拽上传，那就在百度搜索<strong>vue拖拽上传文件</strong>之类的关键词，先看看别人如何实现的，复制别人的代码下来看能不能运行，要是能成功运行则仔细阅读源码，源码有没见过的单词，如FormData、FileReader，直接上MDN看文档，了解清楚这个知识点之后再继续阅读源码。</p><p>了解清楚拖拽上传的相关知识点以及实现思路，我们再动手写代码就是水到渠成的事了。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -vue -node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学习Ajax</title>
      <link href="/2019/03/13/xue-xi-ajax/"/>
      <url>/2019/03/13/xue-xi-ajax/</url>
      
        <content type="html"><![CDATA[<h2 id="AJAX的学习、"><a href="#AJAX的学习、" class="headerlink" title="AJAX的学习、"></a>AJAX的学习、</h2><h3 id="一，XHR简介"><a href="#一，XHR简介" class="headerlink" title="一，XHR简介"></a>一，XHR简介</h3><ul><li>在XHR诞生前，网页要获取客户端和服务器的任何状态更新，都需要刷新一次，在XHR诞生后就可以完全通过JS代码异步实现这一过程。</li><li>HR是一种浏览器API，极大简化了异步通信的过程，开发者并不需要关注底层的实现，因为浏览器会为我们完成这些工作，如连接管理、协议协商、HTTP请求格式化等等。</li><li>XMLHttpRequest 对象提供了对 HTTP 协议的完全的访问，包括做出 POST 和 HEAD 请求以及普通的 GET 请求的能力。XMLHttpRequest 可以同步或异步地返回 Web 服务器的响应，并且能够以文本或者一个 DOM 文档的形式返回内容。<br><a href="https://www.cnblogs.com/syfwhu/p/6116323.html" target="_blank" rel="noopener">原创链接</a></li></ul><h3 id="二，AJAX的简介"><a href="#二，AJAX的简介" class="headerlink" title="二，AJAX的简介"></a>二，AJAX的简介</h3><ol><li><p>AJAX 可以用于创建快速动态的网页。</p></li><li><p>AJAX 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。</p></li><li><p>AJAX = 异步 JavaScript 和 XML。</p></li><li><p>AJAX 是一种用于创建快速动态网页的技术。</p><p>通过在后台与服务器进行少量数据交换，AJAX 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。</p><p>注意：Ajax 不是一种新的编程语言，而是一种用于创建更好更快以及交互性更强的Web应用程序的技术。</p><h3 id="三，AJAX的构造"><a href="#三，AJAX的构造" class="headerlink" title="三，AJAX的构造"></a>三，AJAX的构造</h3><h3 id="四，XHR创建-XMLHttpRequest-对象"><a href="#四，XHR创建-XMLHttpRequest-对象" class="headerlink" title="四，XHR创建 XMLHttpRequest 对象"></a>四，XHR创建 XMLHttpRequest 对象</h3></li></ol><ul><li><p>支持大部分浏览器和IE7+</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> http <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">XMLHttpRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li><li><p>老版本的 Internet Explorer （IE5 和 IE6）</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> http <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ActiveXObject</span><span class="token punctuation">(</span><span class="token string">"Microsoft.XMLHTTP"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li></ul><h4 id="一，对象创建实例"><a href="#一，对象创建实例" class="headerlink" title="一，对象创建实例"></a>一，对象创建实例</h4><p><em>浏览器兼容</em></p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> xmlhttp<span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">//定义一个变量用于后面存储对象  </span>    <span class="token keyword">if</span><span class="token punctuation">(</span>window<span class="token punctuation">.</span>XMLHttpRequest<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//如果浏览器支持XMLHttpRequest对象，通常非IE浏览器支持  </span>    xmlhttp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">XMLHttpRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>window<span class="token punctuation">.</span>ActiveXObject<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//如果浏览器支持ActiveXObject对象，通常是IE    </span>        <span class="token keyword">try</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//尝试创建一个低版本对象，msxml组件2.6版本以下支持      </span>            xmlhttp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ActiveXObject</span><span class="token punctuation">(</span><span class="token string">"Microsoft.XMLHTTP"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">e</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    <span class="token keyword">try</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//尝试创建一个高版本对象，，msxml组件3.0版本以上支持       </span>            xmlhttp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ActiveXObject</span><span class="token punctuation">(</span><span class="token string">"msxml2.XMLHTTP"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token punctuation">}</span>                  <span class="token keyword">catch</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">{</span>                          <span class="token punctuation">}</span>             <span class="token punctuation">}</span></code></pre><h4 id="二，XHR请求"><a href="#二，XHR请求" class="headerlink" title="二，XHR请求"></a>二，XHR请求</h4><p><strong>1.AJAX - 向服务器发送请求</strong><br>解释：XMLHttpRequest 对象用于和服务器交换数据。<br>当你的页面全部加载完毕后，客户端会通过 XMLHttpRequest 对象向服务器请求数据，服务器端接受数据并处理后，向客户端反馈数据。<br><strong>2.向服务器发送请求</strong><br>get请求代码：</p><pre class=" language-javascript"><code class="language-javascript">xmlhttp<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">"GET"</span><span class="token punctuation">,</span><span class="token string">"ajax.txt"</span><span class="token punctuation">,</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      xmlhttp<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><em>避免得到的是缓存的结果</em><br>只需要在后面加上?t=”+Math.random();如：</p><pre class=" language-javascript"><code class="language-javascript">URL<span class="token punctuation">:</span><span class="token string">"ajax.txt?t="</span><span class="token operator">+</span>Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span></code></pre><p>方法解释：</p><ul><li><p>open(method,url,async)<br>method：请求的类型；GET 或 POST<br>url：文件在服务器上的位置<br>async：true（异步）或 false（同步）</p></li><li><p>send(string)<br>将请求发送到服务器。string：仅用于 POST 请求<br>在get中一般不填或null.</p></li><li><p>get请求的特点<br>GET 请求可被缓存<br>GET 请求保留在浏览器历史记录中<br>GET 请求可被收藏为书签<br>GET 请求不应在处理敏感数据时使用<br>GET 请求有长度限制<br>GET 请求只应当用于取回数据</p></li><li><p>希望通过 GET 方法发送信息，请向 URL 添加信息</p><pre class=" language-javascript"><code class="language-javascript">xmlhttp<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">"GET"</span><span class="token punctuation">,</span><span class="token string">"demo_get2.html?fname=Henry&amp;lname=Ford"</span><span class="token punctuation">,</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span> xmlhttp<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li></ul><p>post请求代码</p><pre class=" language-javascript"><code class="language-javascript">xmlhttp<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">"POST"</span><span class="token punctuation">,</span><span class="token string">"demo_post.html"</span><span class="token punctuation">,</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>xmlhttp<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>如果需要像 HTML 表单那样 POST 数据，请使用 setRequestHeader() 来添加 HTTP 头。然后在 send() 方法中规定您希望发送的数据：</p><pre class=" language-javascript"><code class="language-javascript">xmlhttp<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">"POST"</span><span class="token punctuation">,</span><span class="token string">"ajax_test.html"</span><span class="token punctuation">,</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span> xmlhttp<span class="token punctuation">.</span><span class="token function">setRequestHeader</span><span class="token punctuation">(</span><span class="token string">"Content-type"</span><span class="token punctuation">,</span><span class="token string">"application/x-www-form-urlencoded"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> xmlhttp<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token string">"fname=Henry&amp;lname=Ford"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><ul><li><p>setRequestHeader(header,value)</p><p>向请求添加 HTTP 头。</p><p>header: 规定头的名称</p><p>value: 规定头的值</p><h4 id="三，POST中的SETREQUESTHEADER-HEADER-VALUE-详解"><a href="#三，POST中的SETREQUESTHEADER-HEADER-VALUE-详解" class="headerlink" title="三，POST中的SETREQUESTHEADER(HEADER,VALUE)详解"></a>三，POST中的SETREQUESTHEADER(HEADER,VALUE)详解</h4><p>1、XMLObject.setRequestHeader “CONTENT-TYPE”, “application/x-www-form-urlencoded”</p><p>CONTENT-TYPE是什么意思，application/x-www-form-urlencoded是什么意思？</p><p>解答：通常在HTTP协议里，客户端像服务器取得某个网页的时候，必须发送一个HTTP协议的头文件，</p><p>告诉服务器客户端要下载什么信息以及相关的参数，如</p><p>GET /bb.asp?www=1234 HTTP/1.1</p><p>Accept:/</p><p>Accept-Language: zh-cn</p><p>UA-CPU: x86</p><p>Accept-Encoding: gzip, deflate</p><p>User-Agent: Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.2; SV1; .NET CLR 1.1.4322; .NET CLR 2.0.50727)</p><p>Host:<a href="https://ls0904.github.io/" target="_blank" rel="noopener">https://ls0904.github.io/</a></p><p>Connection: Keep-Alive</p><p>Cookie: %C3%F7%CC%EC=%B0%CB;ASPSESSIONIDASDBSDRR=BLEDBIBBCGKBJAKJCFEJKGII</p><p>2、XMLObject.setRequestHeader “CONTENT-TYPE”, “application/x-www-form-urlencoded”<br>setRequestHeader “Connection”, “close”<br>这时HTTP头信息就应该是这样了:<br>GET /bb.asp?www=1234 HTTP/1.1<br>Accept: <em>/</em><br>Accept-Language: zh-cn<br>UA-CPU: x86<br>Accept-Encoding: gzip, deflate<br>User-Agent: Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.2; SV1; .NET CLR 1.1.4322; .NET CLR 2.0.50727)<br>CONTENT-TYPE:application/x-www-form-urlencoded<br>Host: <a href="http://www.e4j.cn:89/" target="_blank" rel="noopener">https://ls0904.github.io/</a><br>Connection: close<br>Cookie: %C3%F7%CC%EC=%B0%CB;ASPSESSIONIDASDBSDRR=BLEDBIBBCGKBJAKJCFEJKGII<br><a href="https://blog.csdn.net/Iamduoluo/article/details/7215639" target="_blank" rel="noopener">关于更多setRequestHeader</a></p></li><li><p>POST请求的特点<br>POST 请求不会被缓存<br>POST 请求不会保留在浏览器历史记录中<br>POST 不能被收藏为书签<br>POST 请求对数据长度没有要求</p></li></ul><h4 id="四，用GET-还是-POST？"><a href="#四，用GET-还是-POST？" class="headerlink" title="四，用GET 还是 POST？"></a>四，用GET 还是 POST？</h4><p>与 POST 相比，GET 更简单也更快，并且在大部分情况下都能用。<br>然而，在以下情况中，请使用 POST 请求：<br>无法使用缓存文件（更新服务器上的文件或数据库）<br>向服务器发送大量数据（POST 没有数据量限制）<br>发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠</p><h4 id="五，XHR响应"><a href="#五，XHR响应" class="headerlink" title="五，XHR响应"></a>五，XHR响应</h4><p><strong>1.AJAX服务器响应</strong><br>由于 HTTP 响应是由服务端发出的，并且服务器做出响应需要时间（比如网速慢等原因），所以我们需要监听服务器响应的状态，然后才能进行处理。<br><strong>服务器响应</strong><br>如需获得来自服务器的响应，请使用 XMLHttpRequest 对象的 responseText 或 responseXML 属性。</p><ul><li><p>responseText</p><p>获得字符串形式的响应数据。</p><p>使用：如果来自服务器的响应并非 XML，请使用 responseText 属性。</p><p>实例代码：</p><pre class=" language-javascript"><code class="language-javascript">document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"myDiv"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>innerHTML<span class="token operator">=</span>xmlhttp<span class="token punctuation">.</span>responseText<span class="token punctuation">;</span></code></pre></li></ul><p><em>提示：对于 responseText 属性，只有当 readyState 属性值变为4时，responseText 属性才可用，因为这表明AJAX请求已经结束！</em></p><ul><li><p>responseXML<br>获得 XML 形式的响应数据。<br>如果来自服务器的响应是 XML，而且需要作为 XML 对象进行解析，请使用 responseXML 属性：</p></li><li><p>response<br>this.response获取到的结果会根据this.responType的变化而变化</p><h4 id="六，客户端的捕获"><a href="#六，客户端的捕获" class="headerlink" title="六，客户端的捕获"></a>六，客户端的捕获</h4></li><li><p>AJAX - onreadystatechange 事件</p><p>当发送一个请求后，客户端需要确定这个请求什么时候会完成，因此，XMLHttpRequest对象提供了 onreadystatechange 件机制来捕获请求的状态，继而实现响应。</p><p>当请求被发送到服务器时，我们需要执行一些基于响应的任务。<br>每当 readyState 改变时，就会触发 onreadystatechange 事件。<br>readyState 属性存有 XMLHttpRequest 的状态信息。</p></li></ul><p><strong>属性介绍</strong></p><ul><li>onreadystatechange<br>存储函数（或函数名），每当 readyState 属性改变时，就会调用该函数。</li><li>readyState<br>存有 XMLHttpRequest 的状态。从 0 到 4 发生变化。</li></ul><ol><li>0: 请求未初始化</li><li>1: 服务器连接已建立</li><li>2: 请求已接收</li><li>3: 请求处理中</li><li>4: 请求已完成，且响应已就绪</li></ol><ul><li>status<br>200: “OK”<br>404: 未找到页面</li></ul><p><em>当 readyState 等于 4 且状态为 200 时服务器响应已做好被处理的准备时所执行的任务</em></p><p><strong>注意</strong><br>onreadystatechange 事件被触发 5 次（0 - 4），对应着 readyState 的每个变化</p><ul><li>0：请求未初始化，还没有调用 open()。</li><li>1：请求已经建立，但是还没有发送，还没有调用 send()。</li><li>2：请求已发送，正在处理中（通常现在可以从响应中获取内容头）。</li><li>3：请求在处理中；通常响应中已有部分数据可用了，没有全部完成。</li><li>4：响应已完成；您可以获取并使用服务器的响应了。</li></ul><h3 id="五，AJAX中需要记的数字"><a href="#五，AJAX中需要记的数字" class="headerlink" title="五，AJAX中需要记的数字"></a>五，AJAX中需要记的数字</h3><h4 id="HTTP的状态码含义。"><a href="#HTTP的状态码含义。" class="headerlink" title="HTTP的状态码含义。"></a>HTTP的状态码含义。</h4><ul><li><p><code>1**</code> 信息，服务器收到请求，需要请求者继续执行操作</p></li><li><p><code>2**</code> 成功，操作被成功接收并处理</p></li><li><pre><code>3**</code></pre></li></ul><p>  重定向，需要进一步的操作以完成请求</p><ul><li><code>301 Moved Permanently</code>。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替</li><li><code>302 Moved Temporarily</code>。与301类似。但资源只是临时被移动。客户端应继续使用原有URI</li><li><code>304 Not Modified</code>。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。<strong>客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源</strong>。</li></ul><ul><li><pre><code>4**</code></pre></li></ul><p>  客户端错误，请求包含语法错误或无法完成请求</p><ul><li><code>400 Bad Request</code> 由于客户端请求有语法错误，不能被服务器所理解。</li><li><code>401 Unauthorized</code> 请求未经授权。这个状态代码必须和WWW-Authenticate报头域一起使用</li><li><code>403 Forbidden</code> 服务器收到请求，但是拒绝提供服务。服务器通常会在响应正文中给出不提供服务的原因</li><li><code>404 Not Found</code> 请求的资源不存在，例如，输入了错误的URL</li></ul><ul><li><pre><code>5**</code></pre></li></ul><p>  服务器错误，服务器在处理请求的过程中发生了错误</p><ul><li><code>500 Internal Server Error</code> 服务器发生不可预期的错误，导致无法完成客户端的请求。</li><li><code>503 Service Unavailable</code> 服务器当前不能够处理客户端的请求，在一段时间之后，服务器可能会恢复正常。<br><a href="https://www.cnblogs.com/yzadd/p/6494628.html" target="_blank" rel="noopener">可以参考此篇文章</a></li></ul><table><thead><tr><th>状态码</th><th align="left">解释</th></tr></thead><tbody><tr><td>1</td><td align="left">请求收到，继续处理</td></tr><tr><td>2</td><td align="left">操作成功并处理</td></tr><tr><td>200</td><td align="left">交易成功</td></tr><tr><td>302</td><td align="left">在其他地址发现请求数据</td></tr><tr><td>400</td><td align="left">错误请求，服务器无法理解</td></tr><tr><td>401</td><td align="left">请求授权失败</td></tr><tr><td>403</td><td align="left">请求收到，但不给服务</td></tr><tr><td>404</td><td align="left">资源不存在</td></tr><tr><td>500</td><td align="left">服务器发生错误</td></tr></tbody></table><h3 id="六-JQuery中的ajax"><a href="#六-JQuery中的ajax" class="headerlink" title="六,JQuery中的ajax"></a>六,JQuery中的ajax</h3><h4 id="一，JQ中一些AJAX的参数"><a href="#一，JQ中一些AJAX的参数" class="headerlink" title="一，JQ中一些AJAX的参数"></a>一，JQ中一些AJAX的参数</h4><pre><code>method //数据的提交方式：get和posturl //数据的提交路径async //是否支持异步刷新，默认是truedata //需要提交的数据dataType //服务器返回数据的类型，例如xml,String,Json等success //请求成功后的回调函数error //请求失败后的回调函数</code></pre><p><strong>例子</strong></p><pre><code>var a=$.ajax({                    type:"get",                    url:"../test.php",                    async:true,                    success: function(){        //请求成功的回调函数                             $("#p").html("请求成功！")}            });    $(function(){            setTimeout(function(){                    $("#c").html(a.responseText)                },4000)            })</code></pre><h3 id="七，ajax的跨域"><a href="#七，ajax的跨域" class="headerlink" title="七，ajax的跨域"></a>七，ajax的跨域</h3><h4 id="一，同源"><a href="#一，同源" class="headerlink" title="一，同源"></a>一，同源</h4><p><strong>解释：</strong> ajax默认访问同源数据，所谓同源就是同协议，同域名，同端口。如果请求非同源的会报错。<br>ajax只能访问同源</p><h4 id="二，SCRIPT标签访问不同源"><a href="#二，SCRIPT标签访问不同源" class="headerlink" title="二，SCRIPT标签访问不同源"></a>二，SCRIPT标签访问不同源</h4><p>访问不同源，我们可以使用script标签，将script中的src设置为不同源的数据，js,php等等<br>如下列例子是通过访问不同源的数据（即跨域访问）</p><pre class=" language-html"><code class="language-html"><span class="token doctype">&lt;!DOCTYPE html></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>淘宝提示词<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>keyword<span class="token punctuation">"</span></span> <span class="token attr-name">placeholder</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>请输入关键字<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>button<span class="token punctuation">"</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>btn<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>查询<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>box<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script language-javascript">    <span class="token keyword">var</span> btn <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"btn"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    btn<span class="token punctuation">.</span>onclick <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">var</span> keyWord <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"keyword"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>value<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//创建节点将外源的数据传入此处</span>        <span class="token keyword">var</span> script <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">"script"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        script<span class="token punctuation">.</span>src <span class="token operator">=</span> <span class="token string">"https://suggest.taobao.com/sug?q="</span><span class="token operator">+</span>keyWord<span class="token operator">+</span><span class="token string">"&amp;callback=haha"</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//利用window的</span>        window<span class="token punctuation">[</span><span class="token string">"haha"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">var</span> list <span class="token operator">=</span> <span class="token string">"&lt;ul>"</span><span class="token punctuation">;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>data<span class="token punctuation">.</span>result<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">var</span> temp <span class="token operator">=</span> data<span class="token punctuation">.</span>result<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token keyword">var</span> tempSug <span class="token operator">=</span> temp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                list <span class="token operator">+</span><span class="token operator">=</span> <span class="token string">"&lt;li>"</span><span class="token operator">+</span>tempSug<span class="token operator">+</span><span class="token string">"&lt;/li>"</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            list <span class="token operator">+</span><span class="token operator">=</span> <span class="token string">"&lt;/ul>"</span><span class="token punctuation">;</span>            <span class="token keyword">var</span> box <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">".box"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            box<span class="token punctuation">.</span>innerHTML <span class="token operator">=</span> list<span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token keyword">var</span> head <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">"head"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        head<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>script<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span></code></pre><p>新学的window属性<br>window[“haha”] = function(data){}；<br>这个相当于一个方法，本例子的hahaa是callback的回调函数自定义。</p><h4 id="三，跨域的封装（SCRIPT）"><a href="#三，跨域的封装（SCRIPT）" class="headerlink" title="三，跨域的封装（SCRIPT）"></a>三，跨域的封装（SCRIPT）</h4><ul><li><p>跨域封装.js</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">myAjax</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">var</span> defaults <span class="token operator">=</span> <span class="token punctuation">{</span>        type<span class="token punctuation">:</span><span class="token string">"get"</span><span class="token punctuation">,</span><span class="token comment" spellcheck="true">//传递数据类型</span>        url<span class="token punctuation">:</span><span class="token string">"#"</span><span class="token punctuation">,</span><span class="token comment" spellcheck="true">//跨域地址名</span>        data<span class="token punctuation">:</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token comment" spellcheck="true">//访问数据</span>        jsonp<span class="token punctuation">:</span><span class="token string">"callback"</span><span class="token punctuation">,</span><span class="token comment" spellcheck="true">//回调函数</span>        jsonpCallback<span class="token punctuation">:</span><span class="token string">"hao"</span><span class="token punctuation">,</span><span class="token comment" spellcheck="true">//回调函数名</span>        success<span class="token punctuation">:</span><span class="token keyword">function</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//服务器返回方法</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>        <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//值覆盖将obj覆盖defaults</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> key <span class="token keyword">in</span> obj<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//对对象obj进行遍历</span>        defaults<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token operator">=</span>obj<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//赋值</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//参数设置</span>    <span class="token keyword">var</span> params <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> arr <span class="token keyword">in</span> defaults<span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token punctuation">{</span>        params <span class="token operator">+</span><span class="token operator">=</span> arr <span class="token operator">+</span><span class="token string">"="</span><span class="token operator">+</span>defaults<span class="token punctuation">.</span>data<span class="token punctuation">[</span>arr<span class="token punctuation">]</span><span class="token operator">+</span><span class="token string">"&amp;"</span><span class="token punctuation">;</span>       <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//去掉最后的&amp;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>params<span class="token punctuation">)</span><span class="token punctuation">{</span>        params <span class="token operator">=</span> params<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span>params<span class="token punctuation">.</span>length<span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        defaults<span class="token punctuation">.</span>url<span class="token operator">+</span><span class="token operator">=</span><span class="token string">"?"</span> <span class="token operator">+</span> params<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//添加回调函数值</span>    defaults<span class="token punctuation">.</span>url <span class="token operator">+</span><span class="token operator">=</span><span class="token string">"&amp;"</span><span class="token operator">+</span>defaults<span class="token punctuation">.</span>jsonp<span class="token operator">+</span><span class="token string">"="</span><span class="token operator">+</span>defaults<span class="token punctuation">.</span>jsonpCallback<span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>defaults<span class="token punctuation">.</span>url<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//创建script的节点</span>    <span class="token keyword">var</span> script  <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">"script"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    script<span class="token punctuation">.</span>src <span class="token operator">=</span> defaults<span class="token punctuation">.</span>url<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//服务器返回的内容</span>    window<span class="token punctuation">[</span>defaults<span class="token punctuation">.</span>jsonpCallback<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">{</span>        defaults<span class="token punctuation">.</span><span class="token function">success</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//把数据传过去</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//将script标签放入head标签</span>    <span class="token keyword">var</span> head <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">"head"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    head<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>script<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>跨域的调用</p><pre class=" language-javascript"><script src="跨域封装.js"><code class="language-javascript"><script src="跨域封装.js"></script>  myAjax({        url:"https://sp0.baidu.com/5a1Fazu8AA54nxGko9WTAnF6hhy/su",//外域数据所在库    jsonp:"cb",//回调函数名    jsonpCallback:"hehe", //window["hehe"]名称      data:{wd:keyWord},//关键字      success:function(data){//服务器返回的函数        console.log(data);        });</code></pre></li></ul><h4 id="四，JQUERY的跨域获取对象"><a href="#四，JQUERY的跨域获取对象" class="headerlink" title="四，JQUERY的跨域获取对象"></a>四，JQUERY的跨域获取对象</h4><p>解释：其实jquery也就是js的封装但没有用到script标签，值的注意的是，dataType是必须要设置为jsonp.</p><pre class=" language-javascript"><code class="language-javascript">$<span class="token punctuation">.</span><span class="token function">ajax</span><span class="token punctuation">(</span><span class="token punctuation">{</span>                        url<span class="token punctuation">:</span><span class="token string">"https://suggest.taobao.com/sug"</span><span class="token punctuation">,</span><span class="token comment" spellcheck="true">//外域数据</span>    data<span class="token punctuation">:</span><span class="token punctuation">{</span>q<span class="token punctuation">:</span>val<span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token comment" spellcheck="true">//搜索关键字</span>    success<span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//服务器返回的函数</span>     code<span class="token operator">...</span><span class="token punctuation">.</span>      <span class="token punctuation">}</span><span class="token punctuation">,</span>            dataType<span class="token punctuation">:</span><span class="token string">"jsonp"</span><span class="token punctuation">,</span><span class="token comment" spellcheck="true">//服务器返回的数据类型</span>    jsonp<span class="token punctuation">:</span><span class="token string">"callback"</span><span class="token punctuation">,</span><span class="token comment" spellcheck="true">//回调函数名</span>    jsonpCallback<span class="token punctuation">:</span><span class="token string">"haha"</span><span class="token punctuation">,</span><span class="token comment" spellcheck="true">//服务器返回时在success中的函数名称</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>例子请求的数据为：<a href="https://suggest.taobao.com/sug?q=val&callback=haha" target="_blank" rel="noopener">https://suggest.taobao.com/sug?q=val&callback=haha</a></p><h4 id="五，JQUERY的跨域获取JSON数据"><a href="#五，JQUERY的跨域获取JSON数据" class="headerlink" title="五，JQUERY的跨域获取JSON数据"></a>五，JQUERY的跨域获取JSON数据</h4><p>解释：利用jsonp只能获取一个对象的数据，当另域中返回的是一个json数据的话，就不能用jsonp来获取。<br>这时就需要利用后台来获取数据然后返回前台数据具体如下：<br><strong>后台获取</strong></p><pre class=" language-javascript"><code class="language-javascript"><span class="token operator">&lt;</span><span class="token operator">?</span>php<span class="token function">header</span><span class="token punctuation">(</span><span class="token string">"Content-Type:text/html;charset=utf-8"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>$province <span class="token operator">=</span>$_GET<span class="token punctuation">[</span><span class="token string">"province"</span><span class="token punctuation">]</span><span class="token punctuation">;</span>$city  <span class="token operator">=</span> $_GET<span class="token punctuation">[</span><span class="token string">"city"</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//将中文编码转为encode编码使能够访问到数据：</span>$pro <span class="token operator">=</span> <span class="token function">urlencode</span><span class="token punctuation">(</span>$province<span class="token punctuation">)</span><span class="token punctuation">;</span>$ci  <span class="token operator">=</span> <span class="token function">urlencode</span><span class="token punctuation">(</span>$city<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//将文件内容读入一个字符串中</span>    $a <span class="token operator">=</span> <span class="token function">file_get_contents</span><span class="token punctuation">(</span><span class="token string">"http://apicloud.mob.com/v1/weather/query?key=2858149d8091c&amp;city="</span><span class="token punctuation">.</span>$ci<span class="token punctuation">.</span><span class="token string">"&amp;province="</span><span class="token punctuation">.</span>$pro<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//将字符串返</span>  <span class="token comment" spellcheck="true">//print_r($a);</span>echo $a<span class="token punctuation">;</span><span class="token operator">?</span><span class="token operator">></span></code></pre><p><strong>注释:</strong>此方法是将访问的数据作为字符串的形式来返回，还可以用其他的方法。<br><strong>前台数据</strong></p><pre class=" language-javascript"><script type="text/javascript"><code class="language-javascript"><script type="text/javascript">            var btn = document.querySelector("#c");            btn.onclick =function(){                var pro = $("#a").val();                var ci= $("#b").val();                                console.log("你好")    ;                            $.ajax({                type:"get",                url:"../phpfile/跨域获取json数据.php?province="+pro+"&city="+ci,                async:true,                        dataType:"json",                success: function(data){                    console.log(data);                    if(data.msg=="success"){                    $("#d").html("查询结果："+data.msg+"--天气为："+data.result[0].weather);                        }else{                        $("#d").html("请输入正确的省份城市");                        }                         },                error: function(){                                        console.log("信息获取失败");                    }            });                }        </script></code></pre><h4 id="跨域总结"><a href="#跨域总结" class="headerlink" title="跨域总结"></a>跨域总结</h4><ol><li>细分可分为script标签，jq利用jsonp跨域，jq利用后端获取json数据。</li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -Ajax </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webpack配置(下)</title>
      <link href="/2019/02/17/webpack-pei-zhi-xia/"/>
      <url>/2019/02/17/webpack-pei-zhi-xia/</url>
      
        <content type="html"><![CDATA[<ol><li><p>使用<code>typescript</code>时需要在根目录下创建一个<code>tsconfig.js</code>的文件</p></li><li><p>关于<code>.babelrc</code>的配置</p><ul><li>直接在<code>webpack.config.js</code>中配置<code>options</code> </li><li>创建<code>.babelrc</code>文件，在该文件中配置</li><li>注意二者取其一就行了，当然也可以两者互补，只要两者合并起来能满足配置需求即可</li></ul><p>在<code>webpack.config.js</code>中的配置是这样的：</p><pre class=" language-javascript"><code class="language-javascript">    <span class="token punctuation">{</span>        test<span class="token punctuation">:</span> <span class="token regex">/\.js$/</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// normal 普通的 loader</span>        use<span class="token punctuation">:</span> <span class="token punctuation">{</span>            loader<span class="token punctuation">:</span> <span class="token string">'babel-loader'</span><span class="token punctuation">,</span>            options<span class="token punctuation">:</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 用babel-loader 需要把 es6 -> es5</span>                presets<span class="token punctuation">:</span> <span class="token punctuation">[</span>                    <span class="token string">'@babel/preset-env'</span><span class="token punctuation">,</span>                    <span class="token string">'@babel/preset-react'</span>                <span class="token punctuation">]</span><span class="token punctuation">,</span>                plugins<span class="token punctuation">:</span> <span class="token punctuation">[</span>                    <span class="token punctuation">[</span><span class="token string">"@babel/plugin-proposal-decorators"</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> <span class="token string">"legacy"</span><span class="token punctuation">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 装饰器语法</span>                    <span class="token punctuation">[</span><span class="token string">"@babel/plugin-proposal-class-properties"</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> <span class="token string">"loose"</span><span class="token punctuation">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 支持 class 语法</span>                    <span class="token string">"@babel/plugin-transform-runtime"</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 运行时，支持 promise 或 gen*</span>                    <span class="token string">"@babel/plugin-syntax-dynamic-import"</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 支持 import then 语法</span>                <span class="token punctuation">]</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>        include<span class="token punctuation">:</span> path<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span> <span class="token string">'../src'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 指定为 src 文件</span>        exclude<span class="token punctuation">:</span> <span class="token regex">/node_modules/</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 排除 node_modules</span>    <span class="token punctuation">}</span></code></pre><p>在<code>.babelrc</code>中的配置是这样的：</p><pre class=" language-javascript"><code class="language-javascript">    <span class="token punctuation">{</span>        presets<span class="token punctuation">:</span> <span class="token punctuation">[</span>            <span class="token string">'@babel/preset-env'</span><span class="token punctuation">,</span>            <span class="token string">'@babel/preset-react'</span>            <span class="token comment" spellcheck="true">// 使用react必须配置的presets项</span>        <span class="token punctuation">]</span><span class="token punctuation">,</span>        plugins<span class="token punctuation">:</span> <span class="token punctuation">[</span>            <span class="token punctuation">[</span><span class="token string">"@babel/plugin-proposal-decorators"</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> <span class="token string">"legacy"</span><span class="token punctuation">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 装饰器语法</span>            <span class="token punctuation">[</span><span class="token string">"@babel/plugin-proposal-class-properties"</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> <span class="token string">"loose"</span><span class="token punctuation">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 支持 class 语法</span>            <span class="token string">"@babel/plugin-transform-runtime"</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 运行时，支持 promise 或 gen*</span>            <span class="token string">"@babel/plugin-syntax-dynamic-import"</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 支持 import then 语法</span>        <span class="token punctuation">]</span>    <span class="token punctuation">}</span></code></pre><p>终于可以摆脱脚手架了。。。。。*(幼稚的想法)</p></li><li><p><code>hash</code>、<code>chunkhash</code>和<code>contenthash</code>的配置</p><ul><li><p><code>hash</code> 计算是跟整个项目的构建相关，也就是说如果配置的是<code>hash</code>，那么只要项目中一个文件发生变化，那么所有的<code>hash</code>都会发生变化，这对缓存来说是一种浪费，使用<code>hash</code>时所有的<code>hash</code>值都是一样的，发生变化时一起变化</p></li><li><pre><code>chunkhash</code></pre><p> 就是解决上面这个问题的，它根据不同的入口文件(</p><pre><code>Entry</code></pre><p>)进行依赖文件解析、构建对应的 </p><pre><code>chunk</code></pre><p>，生成对应的哈希值。即一个</p><pre><code>chunk</code></pre><p>里面修改的内容不会影响到另一个</p><pre><code>chunk</code></pre><p>，只有自己这个</p><pre><code>chunk</code></pre><p>的</p><pre><code>chunkhash</code></pre><p>会发生变化 </p><ul><li>我们更近一步，<code>index.js</code> 和 <code>index.css</code> 同为一个 <code>chunk</code>（<code>index.css</code>是同一个<code>chunk</code>里面抽出来的），如果 <code>index.js</code> 内容发生变化，但是 <code>index.css</code> 没有变化，打包后他们的 <code>hash</code> 都发生变化，这对 <code>css</code> 文件来说是一种浪费。如何解决这个问题呢？<code>contenthash</code> 将根据资源内容创建出唯一 <code>hash</code>，也就是说文件内容不变，hash 就不变。</li></ul></li></ul></li><li><p><code>mini-css-extract-plugin</code>的使用姿势：</p><ul><li>先是装包，在<code>plugins</code>里面<code>new</code>出来一个实例</li></ul><pre class=" language-javascript"><code class="language-javascript">    <span class="token keyword">new</span> <span class="token class-name">MiniCssExtractPlugin</span><span class="token punctuation">(</span><span class="token punctuation">{</span>        filename<span class="token punctuation">:</span> <span class="token string">'index.[contenthash:8].css'</span>        <span class="token comment" spellcheck="true">// 使用contenthash的好处见上一条</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span></code></pre><ul><li>修改<code>rules</code>里面的配置，现在不是用<code>style-loader</code>了，而是要利用<code>mini-css-extract-plugin</code>提供的<code>loader</code> </li></ul><pre class=" language-javascript"><code class="language-javascript">    <span class="token punctuation">{</span>        test<span class="token punctuation">:</span> <span class="token regex">/\.scss$/</span><span class="token punctuation">,</span>        use<span class="token punctuation">:</span> <span class="token punctuation">[</span>            <span class="token comment" spellcheck="true">// 这里替换了原来的style-loader</span>            <span class="token punctuation">{</span>                 loader<span class="token punctuation">:</span> MiniCssExtractPlugin<span class="token punctuation">.</span>loader<span class="token punctuation">,</span>                options<span class="token punctuation">:</span> <span class="token punctuation">{</span>                    hmr<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>                    reloadAll<span class="token punctuation">:</span> <span class="token boolean">true</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">,</span>             <span class="token punctuation">{</span>                loader<span class="token punctuation">:</span> <span class="token string">'css-loader'</span><span class="token punctuation">,</span>                options<span class="token punctuation">:</span> <span class="token punctuation">{</span>                    modules<span class="token punctuation">:</span> <span class="token boolean">true</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">,</span>         <span class="token string">'sass-loader'</span><span class="token punctuation">,</span> <span class="token string">'postcss-loader'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span></code></pre><p>如果不抽离<code>css</code>文件那么所有的<code>css</code>样式内容都会在打包后被放在<code>bundle.js</code>文件中，造成的结果就是<code>bundle.js</code>文件内容过大，如果是一个单页应用的话，需要花更多的时间去下载<code>bundle.js</code>，首屏体验就不好，抽离<code>css</code>文件的作用应该就是这个，将<code>css</code>样式的内容抽离出<code>css</code>文件，通过<code>link</code>标签引入<code>index.html</code>中，这样在下载<code>css</code>内容的时候可以继续构建<code>DOM</code>树也可以继续下载后面的<code>bundle.js</code>，阻塞的只是<code>DOM</code>的渲染和<code>bundle.js</code>的执行，总体来说是提升了性能的。</p></li><li><p><code>optimize-css-assets-webpack-plugin</code><br> 这个插件用于对<code>css</code>资源进行压缩，食用方式是在<code>optimization</code>里面进行配置</p><pre class=" language-javascript"><code class="language-javascript">    <span class="token keyword">const</span> OptimizeCss <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'optimize-css-assets-webpack-plugin'</span><span class="token punctuation">)</span>    <span class="token keyword">const</span> Uglify <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'uglifyjs-webpack-plugin'</span><span class="token punctuation">)</span>    mode<span class="token punctuation">:</span> <span class="token string">'production'</span><span class="token punctuation">,</span>    optimization<span class="token punctuation">:</span> <span class="token punctuation">{</span>        minimizer<span class="token punctuation">:</span> <span class="token punctuation">[</span>            <span class="token keyword">new</span> <span class="token class-name">OptimizeCss</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>            <span class="token keyword">new</span> <span class="token class-name">Uglify</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token punctuation">]</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span></code></pre><p>注意：虽然<code>mode</code>已经设置为<code>production</code>，但是使用了<code>optimize-css-assets-webpack-plugin</code>插件之后如果不使用<code>uglifyjs</code>插件的话<code>js</code>文件将无法压缩，展现出来的是和<code>development</code>模式是一样的，当然如果设置的是<code>development</code>模式的话，即使使用了<code>uglifyjs</code>插件也无法压缩。</p></li><li><p><code>externals</code>配置<br> 譬如通过<code><script></script></code>标签引入了<code>jQuery</code>的<code>CDN</code>，此时在文件中使用<code>$</code>或者<code>window.$</code>都可以直接使用<code>jQuery</code>，也不需打包进<code>bundle.js</code>，但是如果此时又写了<code>import $ from 'jquery'</code>（纯属为了看着顺眼）;的话，<code>jQuery</code>又会被打包进<code>bundle.js</code>，为了避免这样的情况（不用引入的情况偏偏引入了，又不想打包），可以通过配置<code>externals</code>属性来忽略一些不需要打包的内容</p><pre><code>    externals: {        jquery: '$',    }</code></pre></li><li><p>在处理图片时，有三种情况</p><ul><li><p>在</p><pre><code>js</code></pre><p>文件中创建</p><pre><code>img</code></pre><p>，然后添加进</p><pre><code>DOM tree</code></pre><pre class=" language-javascript"><code class="language-javascript">    <span class="token keyword">import</span> imgSrc <span class="token keyword">from</span> <span class="token string">'./a.jpg'</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> image <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Image</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    image<span class="token punctuation">.</span>src <span class="token operator">=</span> imgSrc</code></pre></li><li><p>在</p><pre><code>css</code></pre><p>文件中作为</p><pre><code>background</code></pre><p>使用 </p><pre class=" language-javascript"><code class="language-javascript"><span class="token punctuation">{</span>    backgroung<span class="token punctuation">:</span> <span class="token function">url</span><span class="token punctuation">(</span><span class="token string">'./a.jpg'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 此时不需要先引入，是因为css-loader已经做了这一步操作</span><span class="token punctuation">}</span></code></pre></li><li><p>在</p><pre><code>html</code></pre><p>文件中直接使用 </p><pre><code>    <img src='./a.jpg' /></code></pre><p> 为了将该</p><pre><code>src</code></pre><p>转化为图片打包后的地址，使用一个</p><pre><code>loader</code></pre><p>：</p><pre><code>html-withimg-loader</code></pre><pre class=" language-javascript"><code class="language-javascript">    <span class="token punctuation">{</span>        test<span class="token punctuation">:</span> <span class="token regex">/\.html$/</span><span class="token punctuation">,</span>        loader<span class="token punctuation">:</span> <span class="token string">'html-withimg-loader'</span>    <span class="token punctuation">}</span></code></pre></li></ul><blockquote><p>注意：在配置<code>webpack.config.js</code>时可以像下面这样配置，但是虽然我们只使用了<code>url-loader</code>，但是需要同时装包<code>file-loader</code>，因为由于<code>limit</code>的限制，当图片文件大于<code>200K</code>时会使用<code>file-loader</code>打包出一个图片文件放在<code>build</code>文件夹下，图片大小小于<code>limit</code>限制时是以<code>base64</code>的形式打包进<code>bundle.js</code>文件，也就是说<code>url-loader</code>里面可能会使用到<code>file-loader</code>，这样做的目的也是为了防止<code>bundle.js</code>文件过大，另一个原因是图片过大时编码需要的时间较长，影响打包的速度。但是如果图片较多，会发很多 <code>http</code> 请求，会降低页面性能，所以当图片体积较小时 <code>url-loader</code> 会将引入的图片编码，转为 <code>base64</code> 字符串。再把这串字符打包到文件中，最终只需要引入这个文件就能访问图片了，节省了图片请求。</p></blockquote><pre class=" language-javascript"><code class="language-javascript"><span class="token template-string"><span class="token string">``</span></span><span class="token template-string"><span class="token string">`    {        test: /\.(jpg|png|gif)$/,        use: {            loader: 'url-loader',            options: {                limit: 200*1024,                outputPath: 'img/'                // 会在build目录下创建一个img目录            }        }    },`</span></span><span class="token template-string"><span class="token string">``</span></span></code></pre></li><li><p>关于<code>publicPath</code>的配置，这是代码上线后将资源托管在<code>CDN</code>服务器上，此时<code>html</code>文件中引入各个<code>bundle.js</code>文件不再是本地引入，而是要去<code>CDN</code>服务器上引入，如果继续写成<code>./bundle.js</code>就无法获取到资源，所以就要给所有的引入路径添加上一个公共的路径，譬如说放在<code>http://www.navyblue.com/</code>的<code>CDN</code>服务器上，那么<code>publicPath</code>就设置为<code>http://www.navyblue.com/</code>，这时候在<code>html</code>引入<code>bundle.js</code>的时候就会自动去引入<code>http://www.navyblue.com/bundle.js</code>。如果在<code>output</code>中配置<code>publicPath</code>那么打包出来的所有结果被引入时都会加上公共路径，如果想单独配置，譬如说只给图片加，那么就可以在<code>url-loader</code>的<code>options</code>里面配置<br> <code>{ test: /\.(jpg|png|gif)$/, use: { loader: 'url-loader', options: { limit: 200*1024, outputPath: 'img/', // 会在build目录下创建一个img目录 publicPath: 'http://www.navyblue.com/' } } },</code></p></li><li><p>关于<code>chunk</code>、<code>bundle</code>、<code>module</code>的区别：</p><ul><li><code>module</code>好理解，就是需要被打包的一个个模块</li><li><code>bundle</code>就是打包出来的一个个<code>js</code>文件</li><li><code>chunk</code>：一个<code>entrypoint</code>进去以后，根据各种依赖关系形成一大个<code>chunk</code>，如果在打包一个<code>chunk</code>的过程中需要分割代码，那么分割完最后得到的一个个包就是<code>bundle</code>。</li></ul></li><li><p>关于<code>html-webpack-plugin</code>的使用: 对于多页应用需要new多个<code>plugin</code>出来</p><pre class=" language-javascript"><code class="language-javascript">    <span class="token keyword">new</span> <span class="token class-name">HtmlWebpackPlugin</span><span class="token punctuation">(</span><span class="token punctuation">{</span>        template<span class="token punctuation">:</span> <span class="token string">'./src/index.html'</span><span class="token punctuation">,</span>        minify<span class="token punctuation">:</span> <span class="token punctuation">{</span>            removeAttributeQuotes<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>        filename<span class="token punctuation">:</span> <span class="token string">'home.html'</span><span class="token punctuation">,</span>        <span class="token comment" spellcheck="true">// filename是打包结束后输出的html文件名</span>        chunks<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'main'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>        <span class="token comment" spellcheck="true">// chunks是指该html需要引入的js文件，里面的`main`其实就是一个entrypoint，因为一个entrypoint对应的就是一个chunk</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">new</span> <span class="token class-name">HtmlWebpackPlugin</span><span class="token punctuation">(</span><span class="token punctuation">{</span>        template<span class="token punctuation">:</span> <span class="token string">'./src/index.html'</span><span class="token punctuation">,</span>        minify<span class="token punctuation">:</span> <span class="token punctuation">{</span>            removeAttributeQuotes<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>        filename<span class="token punctuation">:</span> <span class="token string">'other.html'</span><span class="token punctuation">,</span>        chunks<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'sub'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span></code></pre></li><li><p><code>resolve</code>的配置：</p><pre class=" language-javascript"><code class="language-javascript">    resolve<span class="token punctuation">:</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//  解析模块的可选项</span>        modules<span class="token punctuation">:</span> <span class="token punctuation">[</span> <span class="token comment" spellcheck="true">// 模块的查找目录</span>            <span class="token string">"node_modules"</span><span class="token punctuation">,</span>            path<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span> <span class="token string">"app"</span><span class="token punctuation">)</span>        <span class="token punctuation">]</span><span class="token punctuation">,</span>        extensions<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">".js"</span><span class="token punctuation">,</span> <span class="token string">".json"</span><span class="token punctuation">,</span> <span class="token string">".jsx"</span><span class="token punctuation">,</span> <span class="token string">".css"</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 用到的文件的扩展</span>        alias<span class="token punctuation">:</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 模块别名列表</span>            <span class="token string">"module"</span><span class="token punctuation">:</span> <span class="token string">"new-module"</span>            <span class="token comment" spellcheck="true">// 用到的别名：真正的路径</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span></code></pre></li><li><p><code>production mode</code>(生产模式) 可以开箱即用地进行各种优化。 包括压缩，作用域提升，<code>tree-shaking</code> 等。</p></li><li><p>对于<code>cacheGroups</code>的配置:</p><pre><code>    splitChunks: {        chunks: 'all',        minSize: 50000,        minChunks: 2,        // 内部的minChunks可以覆盖这里的minChunks        cacheGroups: {            lodash: {                name: 'mylodash',                test: /[\\/]node_modules[\\/]lodash/,                // 选择匹配的模块                // 譬如第一个包打包的只有lodash，因为没匹配到react所以不会分割到这个包里                minChunks: 1,                priority: 10,                // 打包会根据priority的大小从大到小打包            },            react: {                name: 'myreact',                test: /[\\/]node_modules[\\/]react/,                minChunks: 1,                priority: 5,            },            vendors: {                name: 'myGroups',                test: /[\\/]node_modules1[\\/]/,                priority: -10,                minChunks: 1,            },            default: {                name: 'default',                // 默认有个default配置，但是如果显示写出来又全都没匹配中的话会再次调用一个隐式的default                minChunks: 1,                priority: -20,            }        }    },</code></pre></li><li><p><code>@babel/polyfill</code></p></li></ol><p><code>Babel</code>默认只转换新的<code>JavaScript</code>句法（<code>syntax</code>），而不转换新的<code>API</code>，比如<code>Iterator</code>、<code>Generator</code>、<code>Set</code>、<code>Map</code>、<code>Proxy</code>、<code>Reflect</code>、<code>Symbol</code>、<code>Promise</code>等全局对象，以及一些定义在全局对象上的方法（比如<code>Object.assign</code>）都不会转码。</p><p>举例来说，<code>ES6</code>在<code>Array</code>对象上新增了<code>Array.from</code>方法。<code>Babel</code>就不会转码这个方法。如果想让这个方法运行，必须使用<code>@babel-polyfill</code>，为当前环境提供一个垫片，使得在当前环境下可以执行该方法。</p><ol start="15"><li>关于<code>CSS</code>代码</li></ol><p><code>css-loader</code>:负责解析 <code>CSS</code> 代码，主要是为了处理 <code>CSS</code> 中的依赖，例如 <code>@import</code> 和 <code>url()</code> 等引用外部文件的声明</p><p><code>style-loader</code> 会将 <code>css-loader</code> 解析的结果转变成 <code>JS</code> 代码，运行时动态插入 <code>style</code> 标签来让 <code>CSS</code> 代码生效。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webpack配置(上)</title>
      <link href="/2019/02/03/webpack-pei-zhi-shang/"/>
      <url>/2019/02/03/webpack-pei-zhi-shang/</url>
      
        <content type="html"><![CDATA[<p><code>clean-webpack-plugin</code>的正确使用姿势：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> <span class="token punctuation">{</span> CleanWebpackPlugin <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'clean-webpack-plugin'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>答应我，不会用的去看看文档好吧。。。</p><p><code>optimization</code>里面的相关配置：</p><ul><li>设置<code>minChunks</code>指的是有几个<code>entrypoint</code>进去形成的<code>chunk</code>用到了该<code>module</code>，如果达到了该值就会进行分割。</li><li><code>chunks</code>的参数有<code>async</code>（默认，对异步引入的<code>module</code>进行分割），<code>initial</code>（对同步引入的<code>module</code>进行分割），<code>all</code>（对所有形式引入的<code>module</code>进行分割）</li></ul><pre class=" language-html"><code class="language-html">webpack4`中的`production`模式其实已经默认采用了`uglifyjs</code></pre><p>在进行异步引入操作时需要引进新的插件<code>npm install @babel/plugin-syntax-dynamic-import -D</code>，并修改<code>babel</code>配置：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token punctuation">{</span>    <span class="token string">"presets"</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token string">"@babel/preset-env"</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>        <span class="token string">"corejs"</span><span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">,</span>        <span class="token string">"useBuiltIns"</span><span class="token punctuation">:</span> <span class="token string">"usage"</span>    <span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span>    <span class="token string">"plugins"</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"@babel/plugin-syntax-dynamic-import"</span><span class="token punctuation">]</span><span class="token punctuation">}</span></code></pre><pre><code>magic comments</code></pre><ul><li><code>webpackChunkname</code></li><li><code>webpackPrefetch</code>: <code>prefetch chunk</code> 会在父 <code>chunk</code> 加载结束后开始加载。</li><li><code>webpackPreload</code>: <code>preload chunk</code> 会在父 <code>chunk</code> 加载时，以并行方式开始加载。</li></ul><p><code>package.json</code>里面的<code>scripts</code>配置：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token string">"scripts"</span><span class="token punctuation">:</span> <span class="token punctuation">{</span>    <span class="token string">"build"</span><span class="token punctuation">:</span> <span class="token string">"webpack --config ./config/webpack.config.js"</span><span class="token punctuation">,</span>    <span class="token string">"dev"</span><span class="token punctuation">:</span> <span class="token string">"webpack-dev-server --config ./config/webpack.config.js"</span><span class="token punctuation">}</span><span class="token punctuation">,</span></code></pre><p>设置<code>postcss</code>需要几步操作：</p><ul><li><code>npm install postcss-loader autoprefixer -D</code></li><li>在根目录下添加<code>postcss.config.js</code>，并添加以下代码：</li></ul><pre class=" language-javascript"><code class="language-javascript">    module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>        plugins<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'autoprefixer'</span><span class="token punctuation">)</span><span class="token punctuation">]</span>    <span class="token punctuation">}</span></code></pre><ul><li>修改<code>webpack.config.js</code>里面的配置：</li></ul><pre class=" language-javascript"><code class="language-javascript">    <span class="token punctuation">{</span>        test<span class="token punctuation">:</span> <span class="token regex">/\.(sass|scss)$/</span><span class="token punctuation">,</span>        use<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'style-loader'</span><span class="token punctuation">,</span><span class="token string">'css-loader'</span><span class="token punctuation">,</span><span class="token string">'sass-loader'</span><span class="token punctuation">,</span><span class="token string">'postcss-loader'</span><span class="token punctuation">]</span> <span class="token comment" spellcheck="true">// 顺序不能变</span>    <span class="token punctuation">}</span></code></pre><p>设置<code>css</code>模块的模块化：</p><ul><li>修改<code>webpack.config.js</code>的配置：</li></ul><pre class=" language-javascript"><code class="language-javascript">    <span class="token punctuation">{</span>        test<span class="token punctuation">:</span> <span class="token regex">/\.scss$/</span><span class="token punctuation">,</span>        use<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'style-loader'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>            loader<span class="token punctuation">:</span> <span class="token string">'css-loader'</span><span class="token punctuation">,</span>            options<span class="token punctuation">:</span> <span class="token punctuation">{</span>                modules<span class="token punctuation">:</span> <span class="token boolean">true</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>         <span class="token string">'sass-loader'</span><span class="token punctuation">,</span> <span class="token string">'postcss-loader'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span></code></pre><ul><li>修改<code>index.js</code>里面引入<code>css</code>文件的方式：原理其实就是在打包<code>css</code>文件的时候修改以下<code>css</code>文件里面的类名来防止命名的冲突，如此一来使用时就需要动态的使用类名了</li></ul><pre class=" language-javascript"><code class="language-javascript">    <span class="token keyword">import</span> style <span class="token keyword">from</span> <span class="token string">'./index.scss'</span><span class="token punctuation">;</span>    document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'.d2'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>classList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>style<span class="token punctuation">.</span>d2<span class="token punctuation">)</span></code></pre><p>配置sourceMap：</p><ul><li><code>source-map</code>: 最大而全，会生成独立的<code>map</code>文件，精确到行和列，打包速度慢</li><li><code>cheap-sourse-map</code>: 相对于上面这种区别在于映射到行为止，打包速度快一些，也会产生独立的<code>map</code>文件</li><li><code>inline-source-map</code>: 映射文件以 <code>base64</code> 格式编码，加在 <code>bundle</code> 文件最后，不产生独立的 <code>map</code> 文件。加入 <code>map</code> 文件后，我们可以明显的看到包体积变大了；</li><li><code>cheap-module-eval-source-map</code>: 这个一般是开发环境（<code>dev</code>）推荐使用，在构建速度报错提醒上做了比较好的均衡。</li><li><code>cheap-module-source-map</code>: 一般来说，生产环境是不配 <code>source-map</code> 的，如果想捕捉线上的代码报错，我们可以用这个</li></ul><blockquote><p><code>eval</code>: 打包后的模块都使用 <code>eval()</code> 执行，行映射可能不准；不产生独立的 <code>map</code> 文件</p></blockquote><blockquote><pre><code>cheap`: `map` 映射只显示行不显示列，忽略源自 `loader` 的 `source map</code></pre></blockquote><blockquote><p><code>inline</code>: 映射文件以 <code>base64</code> 格式编码，加在 <code>bundle</code> 文件最后，不产生独立的 <code>map</code> 文件</p></blockquote><blockquote><p><code>module</code>: 增加对 <code>loader</code> <code>source map</code> 和第三方模块的映射</p></blockquote><p><code>webpack</code>可视化打包结果：</p><pre class=" language-javascript"><code class="language-javascript">    npm install webpack<span class="token operator">-</span>bundle<span class="token operator">-</span>analyzer <span class="token operator">-</span>D    <span class="token keyword">const</span> <span class="token punctuation">{</span> BundleAnalyzerPlugin <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'webpack-bundle-analyzer'</span><span class="token punctuation">)</span></code></pre><p>关于<code>tree shaking</code>:</p><ul><li>首先<code>tree shaking</code>只有在<code>es6</code>模块中才会适用，因为<code>es6</code>模块是编译时加载的，支持静态分析，而以往的<code>commonjs</code>模块则是运行时加载，不能静态分析，也就无法进行<code>tree shaking</code>了</li><li><code>import</code>命令输入的变量都是只读的，因为它的本质是输入接口。也就是说，不允许在加载模块的脚本里面，改写接口。但是如果<code>import</code>进来的是一个对象，那么改变属性是可以做到的，但是极力不推荐这么做，因为会影响到其他使用该变量的模块。</li><li><code>export</code>语句输出的接口，与其对应的值是动态绑定关系，即通过该接口，可以取到模块内部实时的值。</li><li><code>import</code>语句是应该写在顶层作用域的，（否则会报错）只有这样才可以支持静态分析，但是可以通过<code>polyfill</code>的方式来支持在块作用域内使用<code>import</code>。</li></ul><p>关于配置<code>proxy</code>的坑：</p><pre class=" language-javascript"><code class="language-javascript">    proxy<span class="token punctuation">:</span> <span class="token punctuation">{</span>        <span class="token string">'/api/ganhuo'</span><span class="token punctuation">:</span> <span class="token punctuation">{</span>            target<span class="token punctuation">:</span> <span class="token string">'http://gank.io/api'</span><span class="token punctuation">,</span>            changeOrigin<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><p>一开始是像上面这样写的<code>proxy</code>，目标请求地址是<code>http://gank.io/api/xiandu/categories</code>，但是在代码中这样<code>axios.get('/api/ganhuo/xiandu/categories')</code>请求时会报404错误，原因是什么呢？把<code>proxy</code>配置修改成下面这样就可以了：</p><pre class=" language-javascript"><code class="language-javascript">    proxy<span class="token punctuation">:</span> <span class="token punctuation">{</span>        <span class="token string">'/api/ganhuo'</span><span class="token punctuation">:</span> <span class="token punctuation">{</span>            target<span class="token punctuation">:</span> <span class="token string">'http://gank.io/api'</span><span class="token punctuation">,</span>            changeOrigin<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>            pathRewrite<span class="token punctuation">:</span> <span class="token punctuation">{</span>                <span class="token string">'^/api/ganhuo'</span><span class="token punctuation">:</span> <span class="token string">''</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><p>因为不写<code>pathRewrite</code>时，相当于<code>webpack</code>认出了<code>/api/gank</code>开头的内容，知道需要代理到<code>http://gank.io/api</code>，但是问题在于，<code>webpack</code>只是简单的把请求的<code>/api/ganhuo/xiandu/categories</code>拼接到了<code>http://gank.io/api</code>后面，最后请求的目标就是<code>http://gank.io/api/api/ganhuo/xiandu/categories</code>，很明显是不对的，所以需要写一个<code>pathRewrite</code></p><p>后续内容请阅读</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>web开发的跨域问题详解</title>
      <link href="/2019/01/24/web-kai-fa-de-kua-yu-wen-ti-xiang-jie/"/>
      <url>/2019/01/24/web-kai-fa-de-kua-yu-wen-ti-xiang-jie/</url>
      
        <content type="html"><![CDATA[<p>应该都遇到过跨域的问题，当我们从一个域名向另一个域名发送 Ajax 请求的时候，打开浏览器控制台就会看到跨域错误，今天我们就来聊聊跨域的问题。</p><h2 id="1-浏览器的同源策略"><a href="#1-浏览器的同源策略" class="headerlink" title="1. 浏览器的同源策略"></a>1. 浏览器的同源策略</h2><p>同源的定义是：如果两个页面的<strong><em>协议</em></strong>，<strong><em>端口</em></strong>（如果有指定）和<strong><em>域名</em></strong>都相同，则两个页面具有相同的<strong>源</strong>。同源策略限制了从同一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的重要安全机制。</p><h2 id="2-跨域错误信息产生的原因"><a href="#2-跨域错误信息产生的原因" class="headerlink" title="2. 跨域错误信息产生的原因"></a>2. 跨域错误信息产生的原因</h2><p>为了说明问题，我们可以做如下实验，我们在本地搭建了开发环境， 由客户端 <a href="http://localhost:3001" target="_blank" rel="noopener">http://localhost:3001</a> 向服务器 <a href="http://localhost:3000" target="_blank" rel="noopener">http://localhost:3000</a> 发送两个请求，一个使用 javascript 异步请求数据，另一个使用 img 标签请求数据，服务器收到请求后，打印接收到请求的日志，如下图所示：</p><p><img src="/.com//1.jpg" alt="发送请求图"></p><p>客户端发送两个请求</p><p><img src="/.com//2.jpg" alt="运行代码"></p><p>服务端打印日志并处理请求</p><p>代开客户端浏览器的控制台，可以看到发出了两个请求，并且都收到了状态码为 200 的响应，同时控制台报了一个错误，即 xhr 请求报错。由此我们可以知道，之所以产生跨域错误信息，原因有以下三条：</p><ul><li>浏览器端的限制（服务端收到了请求并正确返回）</li><li>发送的是 XMLHttpRequest 请求（使用 img 标签发送的请求为 json 类型，并不会报错）</li><li>请求了不同域的资源</li></ul><p>只有同时满足了这三个条件，浏览器才会产生跨域错误。</p><h2 id="3-解决跨域的思路"><a href="#3-解决跨域的思路" class="headerlink" title="3. 解决跨域的思路"></a>3. 解决跨域的思路</h2><p>既然我们知道了跨域错误产生的原因，那么解决思路就很直观了，针对出错的三个原因进行相应的处理即可，相应的解决思路也有三个方向：</p><ul><li>打破浏览器的限制</li><li>不发送 XHR 请求</li><li>解决跨域</li></ul><p>下文将分别进行阐述。</p><h3 id="3-1-打破浏览器的限制"><a href="#3-1-打破浏览器的限制" class="headerlink" title="3.1 打破浏览器的限制"></a>3.1 打破浏览器的限制</h3><p>由上面分析结论可知，之所以出现跨域的错误，实际上是客户端浏览器所做的限制，服务器并未进行限制，因此我们可以通过设置浏览器，使其不进行跨域检查。实际上浏览器也提供了对应的设置选项。</p><p>以 MacOS 下的 Chrome 浏览器为例，在终端中使用命令</p><pre class=" language-javascript"><code class="language-javascript">open <span class="token operator">-</span>n <span class="token operator">/</span>Applications<span class="token operator">/</span>Google\ Chrome<span class="token punctuation">.</span>app<span class="token operator">/</span> <span class="token operator">--</span>args <span class="token operator">--</span>disable<span class="token operator">-</span>web<span class="token operator">-</span>security  <span class="token operator">--</span>user<span class="token operator">-</span>data<span class="token operator">-</span>dir<span class="token operator">=</span><span class="token operator">/</span>Users<span class="token operator">/</span>your<span class="token operator">-</span>computer<span class="token operator">-</span>account<span class="token regex">/MyChromeDevUserData/</span></code></pre><p>打开浏览器，即可禁用 Chrome 浏览器的安全检查功能，同时也会禁用跨域安全检查功能，这样再次拿前面的例子进行测试，发现此时不会报错，同时也可以正确拿到服务端返回的数据。</p><p><img src="/.com//3.jpg" alt></p><p>禁用浏览器安全检查功能</p><p>这种方式虽然可以实现跨域，但是需要每个用户都对浏览器进行设置，同时可能导致潜在的安全隐患，正常情况下不实用。但这个例子充分说明了，跨域错误是前端浏览器所做的限制，与后台服务无关。</p><h3 id="3-2-JSONP实现跨域"><a href="#3-2-JSONP实现跨域" class="headerlink" title="3.2 JSONP实现跨域"></a>3.2 JSONP实现跨域</h3><p>根据思路2，既然跨域问题产生的原因是因为客户端发送了 Ajax 请求，那么我们打破这个条件即可。具体实现方式就是使用 JSONP 来进行跨域请求。</p><blockquote><p>JSONP，是 JSON with Padding 的简称，它是 json 的一种补充使用方式，利用 script 标签来解决跨域问题。JSONP 是非官方协议，他只是前后端一个约定，如果请求参数带有约定的参数，则后台返回 javascript 代码而非 json 数据，返回代码是函数调用形式，函数名即约定值，函数参数即要返回的数据。</p></blockquote><p>JSONP 的实现原理如下图所示：</p><p><img src="/.com//4.jpg" alt="jsonp"></p><p>JSONP实现原理</p><p>首先在客户端 js 中定义一个函数（假设名为 handler），然后动态创建一个 script 标签插入页面中，script 标签的 src 属性即要调用的地址，同时，在调用的 url 中加入一个服务端约定的参数（假设名为 callback，参数值为已定义的函数名 handler），服务端收到请求，如果发现请求的 url 中带有约定的参数，那么就返回一段函数调用形式的 javascript 代码，该段代码的函数名即为 callback 参数的值 handler，函数的参数即为待返回的数据。这样，客户端拿到返回结果后就会执行 handler 函数，对返回的数据进行处理。</p><p>我们使用 jquery 向服务端发送一个 JSONP 格式的请求，从浏览器控制台可以看到请求和对应的响应，如下图所示：</p><p><img src="/.com//5.jpg" alt="返回成功的数据图"></p><p>JSONP请求的响应</p><p>由上图可以看到，发送JSONP请求时，请求的 Type 为 script 类型而非 xhr 类型，这样就打破了跨域报错的三个必要条件，不会产生跨域错误，同时也验证了服务端返回的数据格式为 javascript 代码调用的形式，其中 Jquery331045** 这一长串函数名是 jquery 自动生成的。</p><p>由于 JSONP 的原理是使用 script 标签来加载数据，所以它的兼容性很好，但是使用 JSONP 来解决跨域问题存在以下缺陷：</p><ol><li>只能发送 GET 请求</li><li>发送的不是 XHR 请求，这样导致 XHR 请求中的很多事件都无法进行处理</li><li>服务端需要改动</li></ol><h3 id="3-3-跨域资源共享CORS"><a href="#3-3-跨域资源共享CORS" class="headerlink" title="3.3 跨域资源共享CORS"></a>3.3 跨域资源共享CORS</h3><p>CORS 是一个 W3C 标准，全称是”跨域资源共享”（Cross-origin resource sharing）。它允许浏览器向跨源服务器，发出 XMLHttpRequest 请求，从而克服了 AJAX 只能同源使用的限制。CORS 基于 http 协议关于跨域方面的规定，使用时，客户端浏览器直接异步请求被调用端服务端，在响应头增加响应的字段，告诉浏览器后台允许跨域。</p><p><img src="/.com//6.jpg" alt="跨域错误图"></p><h4 id="3-3-4-CORS请求头和响应头总结"><a href="#3-3-4-CORS请求头和响应头总结" class="headerlink" title="3.3.4 CORS请求头和响应头总结"></a>3.3.4 CORS请求头和响应头总结</h4><p>请求头：</p><ul><li>Origin： 浏览器发出 Ajax 跨域请求之前会添加此头部，值为发送请求的域</li><li>Access-Control-Request-Method：使用了除 GET、POST 请求方法之外的方法，浏览器会添加此头部，值为当前请求方法</li><li>Access-Control-Request-Headers：使用了自定义头部或除了Accept、Accept-Language、Content-Language、Content-Type 之外的头部，浏览器会添加此头部，值为当前的请求方法</li></ul><p>响应头：</p><ul><li>Access-Control-Allow-Origin： 表示服务端允许哪些域请求资源</li><li>Access-Control-Allow-Methods： 当客户端包含 Access-Control-Request-Method 请求头时，服务端需要响应该头部，值通常由 Reauest 的 header 中 Access-Control-Request-Method 取得</li><li>Access-Control-Allow-Headers： 当客户端包含 Access-Control-Request-Headers 请求头时，服务端需要响应该头部，值通常由 Reauest 的 header 中 Access-Control-Request-Headers 取得</li><li>Access-Control-Expose-Headers： 指出客户端通过 XHR 对象的 getResponseHeaders 方法可以获取的响应头有哪些</li><li>Access-Control-Allow-Credentials： 允许带 cookie 的跨域请求</li><li>Access-Control-Max-Age： 预检请求的缓存时间</li></ul><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><p>本文介绍了跨域的原因，重点介绍了使用 JSONP 和 CORS 解决跨域问题的方法。除此之外，实际开发中还其他各种解决跨域问题的思路，本质上，这些方法都是打破跨域错误的三个条件，大家可以自行查资料了解一下。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -跨域 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git使用总结</title>
      <link href="/2018/07/25/git-shi-yong-zong-jie/"/>
      <url>/2018/07/25/git-shi-yong-zong-jie/</url>
      
        <content type="html"><![CDATA[<h2 id="git的常用指令："><a href="#git的常用指令：" class="headerlink" title="git的常用指令："></a>git的常用指令：</h2><p>​    </p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// 在当前目录新建一个Git代码库</span>git init<span class="token comment" spellcheck="true">// 获取所有远程分支（不更新本地分支，另需merge）</span>git fetch <span class="token comment" spellcheck="true">// 下载远程仓库的所有变动</span>git fetch <span class="token punctuation">[</span>remote<span class="token punctuation">]</span><span class="token comment" spellcheck="true">// 增加一个新的远程仓库，并命名</span>git remote add <span class="token punctuation">[</span>shortname<span class="token punctuation">]</span> <span class="token punctuation">[</span>url<span class="token punctuation">]</span><span class="token comment" spellcheck="true">// 恢复暂存区的指定文件到工作区</span>git checkout <span class="token punctuation">[</span>file<span class="token punctuation">]</span><span class="token comment" spellcheck="true">// 恢复某个commit的指定文件到暂存区和工作区</span>git checkout <span class="token punctuation">[</span>commit<span class="token punctuation">]</span> <span class="token punctuation">[</span>file<span class="token punctuation">]</span><span class="token comment" spellcheck="true">// 新建一个分支，并切换到该分支</span>git checkout <span class="token operator">-</span>b <span class="token punctuation">[</span>newBranchName<span class="token punctuation">]</span><span class="token comment" spellcheck="true">// 显示有变更的文件</span>git status<span class="token comment" spellcheck="true">// 显示暂存区和工作区的差异</span>git diff<span class="token comment" spellcheck="true">// 显示当前分支的版本历史</span>git log<span class="token comment" spellcheck="true">// 暂存当前修改，将所有至为HEAD状态</span>git stash</code></pre><h3 id="新建项目"><a href="#新建项目" class="headerlink" title="新建项目"></a>新建项目</h3><pre class=" language-javascript"><code class="language-javascript">git initgit remote add origin http<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>xxxxx<span class="token punctuation">.</span>gitgit add <span class="token punctuation">.</span>git commitgit push <span class="token operator">-</span>u origin master</code></pre><h3 id="常用代码提交操作命令"><a href="#常用代码提交操作命令" class="headerlink" title="常用代码提交操作命令"></a>常用代码提交操作命令</h3><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// 添加指定文件到暂存区</span>git add <span class="token punctuation">[</span>file1<span class="token punctuation">]</span> <span class="token punctuation">[</span>file2<span class="token punctuation">]</span><span class="token comment" spellcheck="true">// 删除工作区文件，并且将这次删除放入暂存区</span>git rm <span class="token punctuation">[</span>file1<span class="token punctuation">]</span> <span class="token punctuation">[</span>file2<span class="token punctuation">]</span><span class="token comment" spellcheck="true">// 提交暂存区到仓库区</span>git commit <span class="token operator">-</span>m <span class="token punctuation">[</span>message<span class="token punctuation">]</span><span class="token comment" spellcheck="true">// 提交工作区自上次commit之后的变化，直接到仓库区</span>git commit <span class="token operator">-</span>a<span class="token comment" spellcheck="true">// 取回远程仓库的变化，并与本地分支合并</span>git pull <span class="token punctuation">[</span>remote<span class="token punctuation">]</span> <span class="token punctuation">[</span>branch<span class="token punctuation">]</span><span class="token comment" spellcheck="true">// 上传本地指定分支到远程仓库</span>git push <span class="token punctuation">[</span>remote<span class="token punctuation">]</span> <span class="token punctuation">[</span>branch<span class="token punctuation">]</span><span class="token comment" spellcheck="true">// 合并指定分支到当前分支</span>git merge <span class="token punctuation">[</span>branchName<span class="token punctuation">]</span></code></pre><h3 id="查看分支"><a href="#查看分支" class="headerlink" title="查看分支"></a>查看分支</h3><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// 查看所有本地分支</span>git branch<span class="token comment" spellcheck="true">// 查看所有远程分支</span>git branch <span class="token operator">-</span>r<span class="token comment" spellcheck="true">// 查看所有本地分支和远程分支</span>git branch <span class="token operator">-</span>a</code></pre><h3 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h3><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// 删除本地分支</span>git branch <span class="token operator">-</span>d <span class="token operator">&lt;</span>branchName<span class="token operator">></span><span class="token punctuation">(</span>删除merge了的分支<span class="token punctuation">)</span>git branch <span class="token operator">-</span>D <span class="token operator">&lt;</span>branchName<span class="token operator">></span><span class="token punctuation">(</span>不管它有没有merge）<span class="token comment" spellcheck="true">// 删除远程分支 </span>git push origin <span class="token operator">--</span><span class="token keyword">delete</span> <span class="token operator">&lt;</span>branchName<span class="token operator">></span> </code></pre><h3 id="重命名远程分支"><a href="#重命名远程分支" class="headerlink" title="重命名远程分支"></a>重命名远程分支</h3><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// 1)删除远程分支 </span>git push origin <span class="token operator">--</span><span class="token keyword">delete</span> <span class="token operator">&lt;</span>oldBranchName<span class="token operator">></span> <span class="token comment" spellcheck="true">// 2)重命名本地分支 </span>git branch <span class="token operator">-</span>m <span class="token operator">&lt;</span>oldBranchName<span class="token operator">></span>  <span class="token operator">&lt;</span>newBranchName<span class="token operator">></span> <span class="token comment" spellcheck="true">// 3)推送本地分支</span>git push origin <span class="token operator">&lt;</span>newBranchName<span class="token operator">></span> </code></pre><h3 id="修改远程仓库地址"><a href="#修改远程仓库地址" class="headerlink" title="修改远程仓库地址"></a>修改远程仓库地址</h3><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// git修改远程仓库地址（http设置密码/更改密码）</span>git remote rm origin<span class="token comment" spellcheck="true">// git remote add origin  http://[username]:[password]@[git地址].git/</span>git remote add origin http<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>username<span class="token punctuation">:</span>password@giturl<span class="token operator">/</span></code></pre><h3 id="打标签-Tag"><a href="#打标签-Tag" class="headerlink" title="打标签(Tag)"></a>打标签(Tag)</h3><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// 查看当前仓库的所有标签</span>git tag <span class="token comment" spellcheck="true">// 搜索符合模式的标签</span>git tag <span class="token operator">-</span>l <span class="token string">'v0.1.*'</span><span class="token comment" spellcheck="true">// 创建轻量标签 git tag [tagname]</span>git tag v1<span class="token number">.0</span><span class="token punctuation">.</span><span class="token number">0</span><span class="token comment" spellcheck="true">// 创建附注标签</span>git tag <span class="token operator">-</span>a v1<span class="token number">.0</span><span class="token punctuation">.</span><span class="token number">0</span> <span class="token operator">-</span>m <span class="token string">"1.0.0版本"</span><span class="token comment" spellcheck="true">// 切换到标签, 与切换分支命令相同 git checkout [tagname]</span>git checkout v1<span class="token number">.0</span><span class="token punctuation">.</span><span class="token number">1</span><span class="token comment" spellcheck="true">// 删除标签  git tag -d [tagname]</span>git tag <span class="token operator">-</span>d v1<span class="token number">.0</span><span class="token punctuation">.</span><span class="token number">1</span><span class="token comment" spellcheck="true">// 将v1.0.0标签提交到git服务器</span>$ git push origin v1<span class="token number">.0</span><span class="token punctuation">.</span><span class="token number">0</span><span class="token comment" spellcheck="true">// 将本地所有标签一次性提交到git服务器</span>$ git push origin –tags </code></pre><h3 id="撤销分支-还没有做push操作"><a href="#撤销分支-还没有做push操作" class="headerlink" title="撤销分支 (还没有做push操作)"></a>撤销分支 (还没有做push操作)</h3><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// 场景1：执行了git add，未commit</span>git reset HEAD <span class="token operator">&lt;</span>filename<span class="token operator">></span><span class="token comment" spellcheck="true">// 场景2：执行了git commit，撤销到某次Commit</span>git reset <span class="token punctuation">[</span><span class="token operator">--</span>hard<span class="token operator">|</span>soft<span class="token operator">|</span>mixed<span class="token operator">|</span>merge<span class="token operator">|</span>keep<span class="token punctuation">]</span> <span class="token punctuation">[</span>commitID<span class="token operator">|</span>HEAD<span class="token punctuation">]</span><span class="token comment" spellcheck="true">// --hard，则缓存区中不会存储这些修改，git会直接丢弃这部分内容；</span><span class="token comment" spellcheck="true">// --soft，该条commit号之后的所有commit的修改都会退回到git缓存区中；</span><span class="token comment" spellcheck="true">// --mixed ，缓存区和你指定的提交同步，但工作目录不受影响；</span><span class="token comment" spellcheck="true">// 可以使用 git push origin HEAD --force 强制将分区内容推送到远程服务器。</span></code></pre><h3 id="回滚分支-还原已push的线上代码"><a href="#回滚分支-还原已push的线上代码" class="headerlink" title="回滚分支 (还原已push的线上代码)"></a>回滚分支 (还原已push的线上代码)</h3><h6 id="场景1：撤销指定文件到指定版本"><a href="#场景1：撤销指定文件到指定版本" class="headerlink" title="场景1：撤销指定文件到指定版本"></a>场景1：撤销指定文件到指定版本</h6><pre class=" language-javascript"><code class="language-javascript"> <span class="token comment" spellcheck="true">// 查看指定文件的历史版本</span>git log <span class="token operator">&lt;</span>filename<span class="token operator">></span> <span class="token comment" spellcheck="true">// 回滚到指定commitID</span>git checkout <span class="token operator">&lt;</span>commitID<span class="token operator">></span> <span class="token operator">&lt;</span>filename<span class="token operator">></span><span class="token comment" spellcheck="true">// 如果你每次更新线上，都会打tag，那可以很快的处理</span>git checkout <span class="token operator">&lt;</span>tag<span class="token operator">></span></code></pre><h6 id="场景2：回滚某次提交"><a href="#场景2：回滚某次提交" class="headerlink" title="场景2：回滚某次提交"></a>场景2：回滚某次提交</h6><p>方式1：使用reset(reset是指将HEAD指针指到指定提交，历史记录中不会出现放弃的提交记录)</p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// 步骤1</span>git reset <span class="token operator">--</span>hard HEAD<span class="token operator">^</span> <span class="token comment" spellcheck="true">// 回退到上个版本</span>git reset <span class="token operator">--</span>hard commit_id    <span class="token comment" spellcheck="true">// 退到/进到 指定commit id</span><span class="token comment" spellcheck="true">// 步骤2</span>git push origin master <span class="token operator">-</span>f <span class="token comment" spellcheck="true">// -f 强制覆盖</span></code></pre><p>方式2：使用revert(revert是放弃指定提交的修改，但是会生成一次新的提交，需要填写提交注释，以前的历史记录都在)</p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// 步骤1</span>git revert <span class="token operator">&lt;</span>commitID<span class="token operator">></span> <span class="token comment" spellcheck="true">// 指定commit id</span>git revert HEAD <span class="token comment" spellcheck="true">// 上个版本</span><span class="token comment" spellcheck="true">// 步骤2</span>git push origin master</code></pre><p><strong>场景3：删除某次提交</strong></p><pre class=" language-javascript"><code class="language-javascript">git rebase <span class="token operator">-</span>i <span class="token string">"commit id"</span><span class="token operator">^</span> <span class="token comment" spellcheck="true">// 最后的^号，意思是commit id的前一次提交</span></code></pre><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><pre class=" language-javascript"><code class="language-javascript"> git config <span class="token operator">--</span>global <span class="token operator">-</span>l<span class="token comment" spellcheck="true">// 设置名字: git config --global user.name  [username]</span>git config <span class="token operator">--</span>global user<span class="token punctuation">.</span>name <span class="token string">"smile"</span><span class="token comment" spellcheck="true">//设置邮箱地址: git config --global user.email  [useremail]</span>git config <span class="token operator">--</span>global user<span class="token punctuation">.</span>email <span class="token number">123456</span>@qq<span class="token punctuation">.</span>com</code></pre><h3 id="设置和取消代理"><a href="#设置和取消代理" class="headerlink" title="设置和取消代理"></a>设置和取消代理</h3><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// 设置</span>git config <span class="token operator">--</span>global https<span class="token punctuation">.</span>proxy http<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span><span class="token number">127.0</span><span class="token punctuation">.</span><span class="token number">0.1</span><span class="token punctuation">:</span><span class="token number">1080</span>git config <span class="token operator">--</span>global https<span class="token punctuation">.</span>proxy https<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span><span class="token number">127.0</span><span class="token punctuation">.</span><span class="token number">0.1</span><span class="token punctuation">:</span><span class="token number">1080</span><span class="token comment" spellcheck="true">//取消</span>git config <span class="token operator">--</span>global <span class="token operator">--</span>unset http<span class="token punctuation">.</span>proxygit config <span class="token operator">--</span>global <span class="token operator">--</span>unset https<span class="token punctuation">.</span>proxy</code></pre><h1 id="git使用过程中的问题-amp-解决方案"><a href="#git使用过程中的问题-amp-解决方案" class="headerlink" title="git使用过程中的问题&解决方案"></a>git使用过程中的问题&解决方案</h1><h6 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h6><p>  <img src="/.com//1.jpg" alt="git碰到问题图"></p><p><strong>解决方案</strong></p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// git config http.postBuffer *bytes*</span>git config http<span class="token punctuation">.</span>postBuffer <span class="token number">524288000</span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>react在前端开发中的优势体现</title>
      <link href="/2018/07/01/react-zai-qian-duan-kai-fa-zhong-de-you-shi-ti-xian/"/>
      <url>/2018/07/01/react-zai-qian-duan-kai-fa-zhong-de-you-shi-ti-xian/</url>
      
        <content type="html"><![CDATA[<h2 id="话不多说，直接进入正题，react的核心点："><a href="#话不多说，直接进入正题，react的核心点：" class="headerlink" title="话不多说，直接进入正题，react的核心点："></a>话不多说，直接进入正题，react的核心点：</h2><p><strong>virtual dom虚拟DOM概念</strong></p><p>它并不直接对DOM进行操作，引入了一个叫做virtual dom的概念，安插在javascript逻辑和实际的DOM之间，好处是减少DOM操作，减少DOM操作的目的是提高浏览器的渲染性能。</p><p>虚拟dom就中小型项目而言，的确从表象上看不出太多的优势，因为它解决的是底层的dom渲染，IO开销问题。但是想想facebook的体量，不难猜出react的诞生是为了解决更复杂更大型的项目开发和管理的。</p><p>实际上React和Vue其实也在操作DOM，只是比较高效地在操作DOM而已，虚拟DOM其实最终也会映射到真实DOM，虽然虚拟DOM只会将变化的部分更新到真实DOM，但实际上直接操作DOM也可以通过某些方式去优化，那么：</p><p>​    1、操作data，不直接操作DOM有什么好处？</p><p>​         更少的代码做更多的事。</p><p>​    2、操作data会给DOM操作带来什么不好的地方吗？</p><p>​          不会，但是不是所有功能“使用操作data”都可以代替的。</p><p>​    3、会不会比直接操作DOM存在什么难度？</p><p>​         不会有难度，但是思维需要有一些转变。</p><p>JSX虽然做了抽象视图，但她是声明式API，能够保证你看一眼就知道组件树的结构，譬如：</p><p>这结构还算清楚吧，基本一眼就知道这个一个面板由输入框、列表、摘要组成，而且布局也清楚了，自上而下。而且，<strong>通过查看一个源文件就可以知道你的组件将会如何渲染。</strong>这是最大的好处，尽管这和 Angular 模板没什么不同。具体参看：<a href="http://www.zplan.net/news.php?id=322" target="_blank" rel="noopener">ReactJS For Stupid People</a></p><p>之前写UI的时候往往为了性能，要设计很多DOM的操作逻辑，用了react之后，这些都不给你做了，由他的state跟props来传递给VDOM，很省事，更专注于UI层面。</p><p>学会了react以及这个JSX语法，你不光可以通过react写web；也可以通过react-native写ios或者android的应用；甚至可以通过react-blessed写terminal可视化应用；当然也可以通过react-native-desktop写桌面应用。因为JSX这种声明式语法实际是在构建一个抽象的视图层，这种抽象可以通过不同适配器适配到各种显示终端，这总够屌吧？</p><p><strong>unidirectional data flow-单向数据流</strong></p><p>React倡导使用flux模式来进行组件间数据传输，这种做法叫unidirectional data flow(单向数据流)，单向数据流的好处是与之前angularJS提出的two-way data binding相比较而言，因为单向，所以各种变化都是可预计、可控制的。不像two-way data binding那样，变化一但复杂起来，大家都互相触发变化，到最后一个地方变了，你根本猜不出来她还会导致其他什么地方跟着一起变。这个需要大量实践才能有所感受，如果你初学，那听听就算了，不必死磕。</p><p><strong>react项目结构更加清晰：</strong></p><p>virtual dom、redux、action，分部分别存放，就象java写后台查数据本来用jdbc一条sql就搞定,但分成action service dao分门别类地存放,这样维护性好,大公司的代码需要规范,这样出了问题好找原因。</p><p><strong>组件化</strong></p><p>一切都是component：代码更加模块化，重用代码更容易，可维护性高。</p><p>这里就涉及到react的 架构，比如：</p><p>smart, dumb component  </p><p>把组件分成两大类 Smart Components(容器)& Dumb Components(颗粒化组件)</p><p>这样做的好处:</p><p>有助理你分离关注点，这样的话更有助于理解你的app的业务逻辑 和 它的ui</p><p>更有助于复用你的dumb组件，你可以将你的dumb组件复用于别的state下，而且这两个state还完全不同</p><p>本质上dumb 组件 其实 就是你的app的调色版。。你可以将它们放到一个页面上。。然后让设计师除了app的业务逻辑，样式随便怎么改，</p><p>参看文章：<a href="https://segmentfault.com/a/1190000004111786" target="_blank" rel="noopener">Smart and Dumb Components</a></p><p>高阶组件(HOC-higher order component) </p><p>高阶组件（HOC）是react中对组件逻辑进行重用的高级技术。但高阶组件本身并不是React API。它只是一种模式，这种模式是由react自身的组合性质必然产生的。</p><p>具体而言，高阶组件就是一个函数，且该函数接受一个组件作为参数，并返回一个新的组件</p><p>const EnhancedComponent = higherOrderComponent(WrappedComponent);</p><p>对比组件将props属性转变成UI，高阶组件则是将一个组件转换成另一个新组件。</p><p>好处：使用高阶组件（HOC）解决交叉问题</p><p>参看文章：<a href="https://react.bootcss.com/react/docs/higher-order-components.html" target="_blank" rel="noopener">高阶组件</a></p><p>总结下，看看一个人的组件化水准，</p><p>pure component</p><p>functional component</p><p>smart, dumb component </p><p>higher order component</p><p>hoc render hijacking</p><p>会用 props.children React.children cloneElement</p><p>提供 instance method</p><p>context</p><p>并理解react 内部实现原理</p><p>懂 setState  是异步的</p><p>懂 synthetic event</p><p>懂 react-dom 分层和 react 没有关系</p><p>懂 reconciler</p><p>懂 fiber  </p><p>具体问题如下：</p><p>\1. 怎么抽象一个带搜索，单多选复合，有请求的 Selector，区分 smart 和 dumped。如果我再往上加功能，比如 autocomplete  等</p><p>\2. 怎么实现对表单的抽象，数据验证怎么统一处理</p><p>\3. 用 react 来实现一个可视化编辑器的引擎，怎么设计，怎么抽象与 model 的交互，再引入 redux 呢，怎么支持第三方组件热插拔</p><p>\4. 用 react 和 redux 模拟多人协作的 Todo，node 作为后端，怎么设计</p><p><strong>同构、纯粹的javascrip</strong></p><p>因为搜索引擎的爬虫程序依赖的是服务端响应而不是JavaScript的执行，预渲染你的应用有助于搜索引擎优化。</p><p>react一些常见问题：</p><p><strong>setState()函数在任何情况下都会导致组件重渲染吗？如果setState()中参数还是原来没有发生任何变化的state呢？</strong></p><p>对setState用得深了，就容易犯错，所以我们开门见山先把理解setState的关键点列出来。</p><p>setState不会立刻改变React组件中state的值；</p><p>setState通过引发一次组件的更新过程来引发重新绘制；</p><p>多次setState函数调用产生的效果会合并</p><p>setState后，知道reader时，才真正改变state的值</p><p>shouldComponentUpdate函数返回false，因为更新被中断，所以不调用render，但是React不会放弃掉对this.state的更新的，依然会更新this.state</p><p><strong>传入 setState 函数的第二个参数的作用是什么？</strong></p><p>该函数会在setState函数调用完成并且组件开始重渲染的时候被调用，我们可以用该函数来监听渲染是否完成（一般没有什么卵用）</p><p> <strong>调用 setState 之后发生了什么？</strong></p><p> 在代码中调用setState函数之后，React 会将传入的参数对象与组件当前的状态合并，然后触发所谓的调和过程（Reconciliation）。经过调和过程，React 会以相对高效的方式根据新的状态构建 React 元素树并且着手重新渲染整个UI界面。在 React 得到元素树之后，React 会自动计算出新的树与老树的节点差异，然后根据差异对界面进行最小化重渲染。在差异计算算法中，React 能够相对精确地知道哪些位置发生了改变以及应该如何改变，这就保证了按需更新，而不是全部重新渲染。</p><p><strong>用shouldComponentUpdate做优化的意义大吗？shouldComponentUpdate将带来可测量和可感知的提升？</strong></p><p>如果不能，那就别用：你可能应该避免用它。据React团队的说，shouldComponentUpdate是一个保证性能的紧急出口，意思就是你不到万不得已就别用它。具体参考：<a href="https://blog.csdn.net/u012937029/article/details/76522930" target="_blank" rel="noopener">什么时候使用shouldComponentUpdate方法?</a></p><p>一般情况下setState()确立后总是触发一次重绘，除非在 shouldComponentUpdate() 中实现了条件渲染逻辑。如果使用可变的对象，但是又不能在 shouldComponentUpdate() 中实现这种逻辑，仅在新 state 和之前的 state 存在差异的时候调用 setState() 可以避免不必要的重新渲染。</p><p><strong>react异步数据如ajax请求应该放在哪个生命周期？</strong></p><p>对于同步的状态改变，是可以放在componentWillMount，对于异步的，最好好放在componentDidMount。但如果此时有若干细节需要处理，比如你的组件需要渲染子组件，而且子组件取决于父组件的某个属性，那么在子组件的componentDidMount中进行处理会有问题：因为此时父组件中对应的属性可能还没有完整获取，因此就让其在子组件的componentDidUpdate中处理。</p><p>具体参考：《<a href="https://www.zhoulujun.cn/html/webfront/ECMAScript/jsBase/2018_0427_8104.html" target="_blank" rel="noopener">react异步数据如ajax请求应该放在哪个生命周期？</a>》</p><p><strong>React 中的 keys 是什么，为什么它们很重要？</strong></p><p>在开发过程中，我们需要保证某个元素的 key 在其同级元素中具有唯一性。在 React Diff 算法中 React 会借助元素的 Key 值来判断该元素是新近创建的还是被移动而来的元素，从而减少不必要的元素重渲染。此外，React 还需要借助 Key 值来判断元素与本地状态的关联关系，因此我们绝不可忽视转换函数中 Key 的重要性。</p><p>keys 是帮助 React 跟踪哪些项目已更改、添加或从列表中删除的属性。</p><p>每个keys 在兄弟元素之间是独一无二的。我们已经谈过几次关于一致化处理（reconciliation）的过程，而且这个一致化处理过程（reconciliation）中的一部分正在执行一个新的元素树与最前一个的差异。keys 使处理列表时更加高效，因为 React 可以使用子元素上的 keys 快速知道元素是新的还是在比较树时才被移动的。</p><p>而且 keys 不仅使这个过程更有效率，而且没有keys，React 不知道哪个本地状态对应于移动中的哪个项目。所以当你 map 的时候，不要忽略了 keys 。</p><p><strong>受控组件( controlled component )与不受控制的组件( uncontrolled component )有什么区别？</strong></p><p>React 的很大一部分是这样的想法，即组件负责控制和管理自己的状态（任何改变代用setSate处理)</p><p>那么不受控组件呢？组件数据不全部是setState来处理，还有DOM交互，比如refs这玩意来操控真实DOM</p><p>虽然不受控制的组件通常更容易实现，因为您只需使用引用从DOM获取值，但是通常建议您通过不受控制的组件来支持受控组件。</p><p>主要原因是受控组件支持即时字段验证，允许您有条件地禁用/启用按钮，强制输入格式，并且更多的是 『the React way』。</p><p><strong>描述事件在React中的处理方式</strong></p><p>为了解决跨浏览器兼容性问题，您的 React 中的事件处理程序将传递SyntheticEvent 的实例，它是 React 的浏览器本机事件的跨浏览器包装器。</p><p>这些 SyntheticEvent 与您习惯的原生事件具有相同的接口，除了它们在所有浏览器中都兼容。有趣的是，React 实际上并没有将事件附加到子节点本身。React 将使用单个事件监听器监听顶层的所有事件。这对于性能是有好处的，这也意味着在更新DOM时，React 不需要担心跟踪事件监听器。</p><p><strong>在什么情况下你会优先选择使用 Class Component 而不是 Functional Component？</strong></p><p>在组件需要包含内部状态或者使用到生命周期函数的时候使用 Class Component ，否则使用函数式组件。</p><p><strong>简单介绍下react的diff</strong></p><p>计算一棵树形结构转换成另一棵树形结构的最少操作，是一个复杂且值得研究的问题。传统 diff 算法通过循环递归对节点进行依次对比，效率低下，算法复杂度达到 O(n^3)，其中 n 是树中节点的总数。O(n^3) 到底有多可怕，这意味着如果要展示1000个节点，就要依次执行上十亿次的比较。这种指数型的性能消耗对于前端渲染场景来说代价太高了！现今的 CPU 每秒钟能执行大约30亿条指令，即便是最高效的实现，也不可能在一秒内计算出差异情况。。React 通过制定大胆的策略，将 O(n^3) 复杂度的问题转换成 O(n) 复杂度的问题。</p><p> react的diff 策略：</p><p> Web UI 中 DOM 节点跨层级的移动操作特别少，可以忽略不计。</p><p> 拥有相同类的两个组件将会生成相似的树形结构，拥有不同类的两个组件将会生成不同的树形结构。 </p><p>对于同一层级的一组子节点，它们可以通过唯一 id 进行区分。 </p><p>基于以上三个前提策略，React 分别对tree diff、component diff以及element diff进行算法优化，事实也证明这三个前提策略是合理且准确的，它保证了整体界面构建的性能。</p><p><strong>tree diff：</strong></p><p>基于策略一，React 对树的算法进行了简洁明了的优化，即对树进行分层比较，两棵树只会对同一层次的节点进行比较。</p><p>既然 DOM 节点跨层级的移动操作少到可以忽略不计，针对这一现象，React 通过 updateDepth 对 Virtual DOM 树进行层级控制，只会对相同颜色方框内的 DOM 节点进行比较，即同一个父节点下的所有子节点。当发现节点已经不存在，则该节点及其子节点会被完全删除掉，不会用于进一步的比较。这样只需要对树进行一次遍历，便能完成整个 DOM 树的比较。</p><p><strong>component diff：</strong></p><p>如果是同一类型的组件，按照原策略继续比较 virtual DOM tree。</p><p>如果不是，则将该组件判断为 dirty component，从而替换整个组件下的所有子节点。对于同一类型的组件，有可能其 Virtual DOM 没有任何变化，如果能够确切的知道这点那可以节省大量的 diff 运算时间，因此 React 允许用户shouldComponentUpdate() 来判断该组件是否需要进行 diff。</p><p><strong>element diff:</strong></p><p>当节点处于同一层级时，React diff 提供了三种节点操作，分别为：<strong>INSERT_MARKUP（插入）、MOVE_EXISTING（移动）和 REMOVE_NODE（删除）</strong>。</p><p>INSERT_MARKUP，新的 component 类型不在老集合里， 即是全新的节点，需要对新节点执行插入操作。</p><p>MOVE_EXISTING，在老集合有新 component 类型，且 element 是可更新的类型，generateComponentChildren 已调用 receiveComponent，这种情况下 prevChild=nextChild，就需要做移动操作，可以复用以前的 DOM 节点。</p><p>REMOVE_NODE，老 component 类型，在新集合里也有，但对应的 element 不同则不能直接复用和更新，需要执行删除操作，或者老 component 不在新集合里的，也需要执行删除操作。</p><p><strong>总结</strong></p><p>React 通过制定大胆的 diff 策略，将 O(n3) 复杂度的问题转换成 O(n) 复杂度的问题；</p><p>React 通过分层求异的策略，对 tree diff 进行算法优化；</p><p>React 通过相同类生成相似树形结构，不同类生成不同树形结构的策略，对 component diff 进行算法优化；</p><p>React 通过设置唯一 key的策略，对 element diff 进行算法优化；</p><p>建议，在开发组件时，保持稳定的 DOM 结构会有助于性能的提升；</p><p>建议，在开发过程中，尽量减少类似将最后一个节点移动到列表首部的操作，当节点数量过大或更新操作过于频繁时，在一定程度上会影响 React 的渲染性能。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React中类组件与函数组件的区别</title>
      <link href="/2018/06/19/react-lei-zu-jian-yu-han-shu-zu-jian-de-qu-bie/"/>
      <url>/2018/06/19/react-lei-zu-jian-yu-han-shu-zu-jian-de-qu-bie/</url>
      
        <content type="html"><![CDATA[<pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">class</span> <span class="token class-name">Hello</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>     <span class="token comment" spellcheck="true">// 用类组件定义一个Hello组件</span>   constructor <span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">super</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">=</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>render <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span><span class="token punctuation">(</span>    <span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">Welcome</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//用函数组件定义个一个Welcome组件</span>  <span class="token keyword">return</span> <span class="token operator">&lt;</span>h1<span class="token operator">></span>Hello<span class="token punctuation">,</span> <span class="token punctuation">{</span>props<span class="token punctuation">.</span>name<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>h1<span class="token operator">></span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><ol><li>函数组件看似只是一个返回值是DOM结构的函数，其实它的背后是无状态组件（Stateless Components）的思想。<strong>函数组件中，你无法使用State，也无法使用组件的生命周期方法，</strong>这就决定了函数组件都是展示性组件（Presentational Components），接收Props，渲染DOM，而不关注其他逻辑。</li><li>函数组件中没有this。所以你再也不需要考虑this带来的烦恼。而在类组件中，你依然要记得绑定this这个琐碎的事情。而要想改变类组件中this得指向，你需要用bing方法去修改，而不能使用apply、call方法。因为后者会立即执行，只有bind是返回一个回调函数。</li><li>函数组件更容易理解。当你看到一个函数组件时，你就知道它的功能只是接收属性，渲染页面，它不执行与UI无关的逻辑处理，它只是一个纯函数。而不用在意它返回的DOM结构有多复杂。</li><li>性能。目前React还是会把函数组件在内部转换成类组件，所以使用函数组件和使用类组件在性能上并无大的差异。但是，React官方已承诺，未来将会优化函数组件的性能，因为<strong>函数组件不需要考虑组件状态和组件生命周期方法中的各种比较校验</strong>，所以有很大的性能提升空间。</li><li>函数组件迫使你思考最佳实践。这是最重要的一点。组件的主要职责是UI渲染，理想情况下，所有的组件都是展示性组件，每个页面都是由这些展示性组件组合而成。如果一个组件是函数组件，那么它当然满足这个要求。所以牢记函数组件的概念，可以让你在写组件时，先思考这个组件应不应该是展示性组件。更多的展示性组件意味着更多的组件有更简洁的结构，更多的组件能被更好的复用。</li><li>类组件可以帮帮助我们实现动态数据的渲染，本身使用得JSX语法可以采用虚拟DOM得方法减少去操作真实DOM得操作可以达到性能优化得作用，同时也可以提高组件得复用性。</li></ol><p>是由用类组件还是函数组件你可以按照自己得需求来，当你需要动态得去渲染数据得时候那么你就该用类组件了。如果你只需要去实现某个属性那么你可以考虑用函数组件更为简单一些。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>yarn的基本用法</title>
      <link href="/2018/04/05/yarn-de-ji-ben-yong-fa/"/>
      <url>/2018/04/05/yarn-de-ji-ben-yong-fa/</url>
      
        <content type="html"><![CDATA[<h1 id="yarn的基本用法："><a href="#yarn的基本用法：" class="headerlink" title="yarn的基本用法："></a>yarn的基本用法：</h1><pre><code> ## 1、先初始化一个新的项目</code></pre><p><code>yarn init</code></p><h2 id="2、添加一个依赖包"><a href="#2、添加一个依赖包" class="headerlink" title="2、添加一个依赖包"></a>2、添加一个依赖包</h2><pre class=" language-javascript"><code class="language-javascript">yarn add <span class="token punctuation">[</span><span class="token keyword">package</span><span class="token punctuation">]</span>yarn add <span class="token punctuation">[</span><span class="token keyword">package</span><span class="token punctuation">]</span>@<span class="token punctuation">[</span>version<span class="token punctuation">]</span>yarn add <span class="token punctuation">[</span><span class="token keyword">package</span><span class="token punctuation">]</span>@<span class="token punctuation">[</span>tag<span class="token punctuation">]</span></code></pre><h2 id="3、安装所有的依赖包"><a href="#3、安装所有的依赖包" class="headerlink" title="3、安装所有的依赖包"></a>3、安装所有的依赖包</h2><p><code>yarn</code>或者<code>yarn install</code></p><h2 id="4、npm与yarn命令比较"><a href="#4、npm与yarn命令比较" class="headerlink" title="4、npm与yarn命令比较"></a>4、npm与yarn命令比较</h2><table><thead><tr><th><strong>NPM</strong></th><th>YARN</th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>npm init</td><td>yarn init</td><td>初始化某个项目</td></tr><tr><td>npm install</td><td>yarn install</td><td>默认的安装依赖操作</td></tr><tr><td>npm install –save</td><td>yarn add</td><td>安装某个依赖，并且默认保存到package.</td></tr><tr><td>npm uninstall –save</td><td>yarn remove</td><td>移除某个依赖项目</td></tr><tr><td>npm install  –save-dev</td><td>yarn add  —dev</td><td>安装某个开发时依赖项目</td></tr><tr><td>npm update  –save</td><td>yarn upgrade</td><td>更新某个依赖项目</td></tr><tr><td>npm install  –global</td><td>yarn global add</td><td>安装某个全局依赖项目</td></tr><tr><td>npm publish/login/logout</td><td>yarn publish/login/logout</td><td>发布/登录/登出，一系列NPM Registry操作</td></tr><tr><td>npm run</td><td>yarn run</td><td>运行某个命令</td></tr></tbody></table><p>总结：Yarn是由Facebook、Google、Exponent 和 Tilde 联合推出了一个新的 JS 包管理工具 ,它弥补 npm 的一些缺陷,主要优点是速度快,安装版本统一,更简洁的输出,更好的语义化.</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -yarn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一步步认识Vuex</title>
      <link href="/2018/03/22/yi-bu-bu-ren-shi-vuex/"/>
      <url>/2018/03/22/yi-bu-bu-ren-shi-vuex/</url>
      
        <content type="html"><![CDATA[<p>如图，<code>Vuex</code>看起来是一个仓库，一层一层得关系牵连，其实它就是一个专为<code>vue.js</code>管理得仓库。</p><h3 id="一、为什么需要使用Vuex呢？"><a href="#一、为什么需要使用Vuex呢？" class="headerlink" title="一、为什么需要使用Vuex呢？"></a>一、为什么需要使用<code>Vuex</code>呢？</h3><p>​        1、项目越写越大，功能越写越复杂，当<code>vue.js</code>应用程序遇到多个组件共享状态时，单向数据流得简洁性很容易被破坏。</p><p>​        2、组件之间通信很复杂得情况下</p><p>​        3、项目中使用了路由，并且路由页面组件中需要通信得时候。</p><p>​        4、项目遇到难点，写不下去得时候就该用<code>vuex</code>了。</p><h3 id="二、Vuex的操作流程："><a href="#二、Vuex的操作流程：" class="headerlink" title="二、Vuex的操作流程："></a>二、<code>Vuex</code>的操作流程：</h3><p>​        1、要先创建仓库，将我们项目中组件上需要恭喜的数据放置到我们仓库中state的位置/</p><p>​        2、组件要使用仓库中state的数据，就从仓库里面拿出来用。</p><p>​        3、要修改仓库中state的数据，</p><p>​                    1、commit(提交) mutation</p><p>​                    2、dispath（派发） action -> commit mutation</p><p>​        4、然后仓库中state数据发生变化，组件就会得到更新</p><h4 id="vuex的使用："><a href="#vuex的使用：" class="headerlink" title="vuex的使用："></a><code>vuex</code>的使用：</h4><p>​                1、安装vuex <code>npm install --save vuex</code></p><p>​                2、项目<code>src/store/index.js</code>文件中创建仓库的实例对象</p><p>​                3、要<code>main.js中new Vue</code>实例的地方 配置一个<code>store</code>的选项，选项的值就是第二步中实例的对象。</p><h3 id="三、如何将仓库中的数据拿到组件中去使用"><a href="#三、如何将仓库中的数据拿到组件中去使用" class="headerlink" title="三、如何将仓库中的数据拿到组件中去使用"></a>三、如何将仓库中的数据拿到组件中去使用</h3><p>​     <code>this.$store</code>就是仓库的实例对象</p><p>​        1、直接使用this,$store的方式在组件template模板中使用（不推荐）</p><p>​        2、组件中使用计算属性去拿仓库的数据</p><p>​        3、借助<code>vuex</code>提供的辅助函数<code>mapState</code></p><p>​                <code>mapState([ ])</code>组件的<code>Computed</code>的<code>key</code>必须要跟<code>State</code>中的<code>key</code>一致</p><p>​                <code>mapState ({ })</code>-组件的<code>Computed</code>的<code>key</code>可以自定义如</p><p>​        4、将组件自身的<code>computed</code>与<code>State</code>的<code>computed</code>结合        …为展开运算符</p><pre class=" language-vue"><code class="language-vue">computed: {  ...mapState(['title']),  firstName () {    return this.name.split('')[0]  }},</code></pre><h3 id="四、如何修改仓库中的数据"><a href="#四、如何修改仓库中的数据" class="headerlink" title="四、如何修改仓库中的数据"></a>四、如何修改仓库中的数据</h3><ol><li>先需要在仓库中定义我们的<code>mutation</code></li><li>在组件中提交这个<code>mutaion</code><ol><li><code>this.$store.commit</code>(‘mutaion的名字’, 要传递的参数)</li><li><code>this.$store.commit</code>({ type: mutaion的名字, 其余的参数 })</li><li><code>mapMutations</code> 辅助函数</li></ol></li><li><code>mutation</code>不允许异步代码的</li></ol><h3 id="五、如何在仓库中-写异步代码-actions"><a href="#五、如何在仓库中-写异步代码-actions" class="headerlink" title="五、如何在仓库中 写异步代码 (actions)"></a>五、如何在仓库中 写异步代码 (actions)</h3><ol><li>每一个action里面都可以写异步代码，但是action并不能修改state中的数据，真正修改数据的还是 mutaction</li><li>在组件中如何派发这个action<ol><li><code>this.$store.dispatch</code>(‘action的名字’)</li><li>借助<code>mapActions</code> 辅助函数</li></ol></li></ol><p>至此，<code>vuex</code>中的常用的一些入门知识使用算是简单的分享完了，当然了，相信这些只是一些皮毛！只能说是给予刚接触<code>vuex</code>的初学者一个参考与了解吧！有哪里不明白的或不对的，留言下，咱们可以一起讨论、共同学习！</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -vuex </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
