<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>react入门</title>
      <link href="/2019/06/17/react-ru-men/"/>
      <url>/2019/06/17/react-ru-men/</url>
      
        <content type="html"><![CDATA[<h1 id="JSX简介"><a href="#JSX简介" class="headerlink" title="JSX简介"></a>JSX简介</h1><blockquote><pre class=" language-html"><code class="language-html">const element = <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span><span class="token punctuation">></span></span>Hello, world!<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">></span></span>;</code></pre></blockquote><p>这个有趣得标签语法就叫<code>JSX</code>，是一个 <code>JavaScript</code>的语法扩展。在React中配合使用<code>JSX</code>，<code>JSX</code>可以很好地描述UI应该呈现出它应有的交互的本质形式。它具有JavaScript全部的功能。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> react </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React中类组件与函数组件的区别</title>
      <link href="/2018/06/19/react-lei-zu-jian-yu-han-shu-zu-jian-de-qu-bie/"/>
      <url>/2018/06/19/react-lei-zu-jian-yu-han-shu-zu-jian-de-qu-bie/</url>
      
        <content type="html"><![CDATA[<pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">class</span> <span class="token class-name">Hello</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>     <span class="token comment" spellcheck="true">// 用类组件定义一个Hello组件</span>   constructor <span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">super</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">=</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>render <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span><span class="token punctuation">(</span>    <span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">Welcome</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//用函数组件定义个一个Welcome组件</span>  <span class="token keyword">return</span> <span class="token operator">&lt;</span>h1<span class="token operator">></span>Hello<span class="token punctuation">,</span> <span class="token punctuation">{</span>props<span class="token punctuation">.</span>name<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>h1<span class="token operator">></span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><ol><li>函数组件看似只是一个返回值是DOM结构的函数，其实它的背后是无状态组件（Stateless Components）的思想。<strong>函数组件中，你无法使用State，也无法使用组件的生命周期方法，</strong>这就决定了函数组件都是展示性组件（Presentational Components），接收Props，渲染DOM，而不关注其他逻辑。</li><li>函数组件中没有this。所以你再也不需要考虑this带来的烦恼。而在类组件中，你依然要记得绑定this这个琐碎的事情。而要想改变类组件中this得指向，你需要用bing方法去修改，而不能使用apply、call方法。因为后者会立即执行，只有bind是返回一个回调函数。</li><li>函数组件更容易理解。当你看到一个函数组件时，你就知道它的功能只是接收属性，渲染页面，它不执行与UI无关的逻辑处理，它只是一个纯函数。而不用在意它返回的DOM结构有多复杂。</li><li>性能。目前React还是会把函数组件在内部转换成类组件，所以使用函数组件和使用类组件在性能上并无大的差异。但是，React官方已承诺，未来将会优化函数组件的性能，因为<strong>函数组件不需要考虑组件状态和组件生命周期方法中的各种比较校验</strong>，所以有很大的性能提升空间。</li><li>函数组件迫使你思考最佳实践。这是最重要的一点。组件的主要职责是UI渲染，理想情况下，所有的组件都是展示性组件，每个页面都是由这些展示性组件组合而成。如果一个组件是函数组件，那么它当然满足这个要求。所以牢记函数组件的概念，可以让你在写组件时，先思考这个组件应不应该是展示性组件。更多的展示性组件意味着更多的组件有更简洁的结构，更多的组件能被更好的复用。</li><li>类组件可以帮帮助我们实现动态数据的渲染，本身使用得JSX语法可以采用虚拟DOM得方法减少去操作真实DOM得操作可以达到性能优化得作用，同时也可以提高组件得复用性。</li></ol><p>是由用类组件还是函数组件你可以按照自己得需求来，当你需要动态得去渲染数据得时候那么你就该用类组件了。如果你只需要去实现某个属性那么你可以考虑用函数组件更为简单一些。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一步步认识Vuex</title>
      <link href="/2018/03/22/yi-bu-bu-ren-shi-vuex/"/>
      <url>/2018/03/22/yi-bu-bu-ren-shi-vuex/</url>
      
        <content type="html"><![CDATA[<p>如图，<code>Vuex</code>看起来是一个仓库，一层一层得关系牵连，其实它就是一个专为<code>vue.js</code>管理得仓库。</p><h3 id="一、为什么需要使用Vuex呢？"><a href="#一、为什么需要使用Vuex呢？" class="headerlink" title="一、为什么需要使用Vuex呢？"></a>一、为什么需要使用<code>Vuex</code>呢？</h3><p>​        1、项目越写越大，功能越写越复杂，当<code>vue.js</code>应用程序遇到多个组件共享状态时，单向数据流得简洁性很容易被破坏。</p><p>​        2、组件之间通信很复杂得情况下</p><p>​        3、项目中使用了路由，并且路由页面组件中需要通信得时候。</p><p>​        4、项目遇到难点，写不下去得时候就该用<code>vuex</code>了。</p><h3 id="二、Vuex的操作流程："><a href="#二、Vuex的操作流程：" class="headerlink" title="二、Vuex的操作流程："></a>二、<code>Vuex</code>的操作流程：</h3><p>​        1、要先创建仓库，将我们项目中组件上需要恭喜的数据放置到我们仓库中state的位置/</p><p>​        2、组件要使用仓库中state的数据，就从仓库里面拿出来用。</p><p>​        3、要修改仓库中state的数据，</p><p>​                    1、commit(提交) mutation</p><p>​                    2、dispath（派发） action -> commit mutation</p><p>​        4、然后仓库中state数据发生变化，组件就会得到更新</p><h4 id="vuex的使用："><a href="#vuex的使用：" class="headerlink" title="vuex的使用："></a><code>vuex</code>的使用：</h4><p>​                1、安装vuex <code>npm install --save vuex</code></p><p>​                2、项目<code>src/store/index.js</code>文件中创建仓库的实例对象</p><p>​                3、要<code>main.js中new Vue</code>实例的地方 配置一个<code>store</code>的选项，选项的值就是第二步中实例的对象。</p><h3 id="三、如何将仓库中的数据拿到组件中去使用"><a href="#三、如何将仓库中的数据拿到组件中去使用" class="headerlink" title="三、如何将仓库中的数据拿到组件中去使用"></a>三、如何将仓库中的数据拿到组件中去使用</h3><p>​     <code>this.$store</code>就是仓库的实例对象</p><p>​        1、直接使用this,$store的方式在组件template模板中使用（不推荐）</p><p>​        2、组件中使用计算属性去拿仓库的数据</p><p>​        3、借助<code>vuex</code>提供的辅助函数<code>mapState</code></p><p>​                <code>mapState([ ])</code>组件的<code>Computed</code>的<code>key</code>必须要跟<code>State</code>中的<code>key</code>一致</p><p>​                <code>mapState ({ })</code>-组件的<code>Computed</code>的<code>key</code>可以自定义如</p><p>​        4、将组件自身的<code>computed</code>与<code>State</code>的<code>computed</code>结合        …为展开运算符</p><pre class=" language-vue"><code class="language-vue">computed: {  ...mapState(['title']),  firstName () {    return this.name.split('')[0]  }},</code></pre><h3 id="四、如何修改仓库中的数据"><a href="#四、如何修改仓库中的数据" class="headerlink" title="四、如何修改仓库中的数据"></a>四、如何修改仓库中的数据</h3><ol><li>先需要在仓库中定义我们的<code>mutation</code></li><li>在组件中提交这个<code>mutaion</code><ol><li><code>this.$store.commit</code>(‘mutaion的名字’, 要传递的参数)</li><li><code>this.$store.commit</code>({ type: mutaion的名字, 其余的参数 })</li><li><code>mapMutations</code> 辅助函数</li></ol></li><li><code>mutation</code>不允许异步代码的</li></ol><h3 id="五、如何在仓库中-写异步代码-actions"><a href="#五、如何在仓库中-写异步代码-actions" class="headerlink" title="五、如何在仓库中 写异步代码 (actions)"></a>五、如何在仓库中 写异步代码 (actions)</h3><ol><li>每一个action里面都可以写异步代码，但是action并不能修改state中的数据，真正修改数据的还是 mutaction</li><li>在组件中如何派发这个action<ol><li><code>this.$store.dispatch</code>(‘action的名字’)</li><li>借助<code>mapActions</code> 辅助函数</li></ol></li></ol><p>至此，<code>vuex</code>中的常用的一些入门知识使用算是简单的分享完了，当然了，相信这些只是一些皮毛！只能说是给予刚接触<code>vuex</code>的初学者一个参考与了解吧！有哪里不明白的或不对的，留言下，咱们可以一起讨论、共同学习！</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> vuex </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -vuex </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
