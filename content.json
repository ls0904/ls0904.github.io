{"meta":{"title":"星空下的颗粒","subtitle":"深中有只程序猿，圳中独闯只为王。只为成为独当一面的·Web·前端工程师！","description":"让自己在这个博客里面记录自己的一些见解，一些在代码中的疑难以及收获。","author":"Ls-tomatoes","url":"http://yoursite.com","root":"/"},"pages":[{"title":"about","date":"2019-06-04T05:04:20.000Z","updated":"2019-06-15T01:09:25.254Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"categories","date":"2019-06-04T05:01:12.000Z","updated":"2019-06-15T01:08:16.519Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"garlly","date":"2019-06-15T02:34:03.000Z","updated":"2019-06-15T02:34:31.102Z","comments":true,"path":"garlly/index.html","permalink":"http://yoursite.com/garlly/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"tags","date":"2019-06-04T05:03:49.000Z","updated":"2019-06-15T01:08:47.768Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"friends","date":"2018-12-12T13:25:30.000Z","updated":"2019-06-15T01:10:20.470Z","comments":true,"path":"friends/index.html","permalink":"http://yoursite.com/friends/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"}],"posts":[{"title":"webpack具体配置详情","slug":"webpack具体配置详情 -V4.0","date":"2019-07-18T04:33:34.000Z","updated":"2019-07-18T04:39:14.941Z","comments":true,"path":"2019/07/18/webpack-ju-ti-pei-zhi-xiang-qing-v4.0/","link":"","permalink":"http://yoursite.com/2019/07/18/webpack-ju-ti-pei-zhi-xiang-qing-v4.0/","excerpt":"","text":"webpack看这一篇就够了，webpack4.0配置详解。什么是webpack，webpack给我们解决了哪些实际问题？ 什么是webpack? webpack 它是基于 Node.js 开发出来的是前端的一个项目构建工具。 webpack给我们解决了哪些实际的问题？ 你是否和我一样整天被这种包与包之间的依赖关系搞得头皮发麻。比如你需要用到easyUI那么你就得引入jQuery,并且jQuery必须在easyUI引入之前引入。那这个就有点烦了,每个页面都必须引入。 引入过多的静态资源后，网页打开需要的二次请求量也就高了，这样网页打开就会比较慢，那么项目经理找你的次数也会增加，加班次数增加，啊啊啊啊！ 这时候webpack就来了，可以很好的解决以上的问题，从此再也不用加班了。 tips:除了webpack这个打包工具外还有Gulp也比较常见。 webpack完美实现资源的合并、打包、压缩、混淆等诸多功能。 从此写代码无烦恼，天天吃饭吃的好。 webpack官网 webpack的安装 npm i webpack -g全局安装webpack，这样就能在全局使用webpack的命令 在项目根目录中运行npm i webpack -D安装到项目开发依赖中 webpack的配置文件 其实webpack也可以不需要配置文件，然后就靠输命令来构建。(如果你喜欢你可以在项目上试试,公司第二天辞退QAQ) 使用webpack的配置文件。 首先创建webpack的配置文件，在项目根目录创建webpack.config.js。 配置 webpack,你得先清楚这两个概念:’出口(output)’和’入口(entry)’。 入口就相当于工厂中的原材料，出口就是做成的产品（够形象了吧）。 入口简单讲就是你自己写的代码，出口呢就是webpack帮你处理过后的代码（你：’我为什么要给他处理，我自己不知道我写的啥吗？‘。先别抬杠，别着急慢慢看）。 webpack.config.js简单的配置文件如下： // 导入处理路径的模块 var path = require('path'); // 导出一个配置对象，将来webpack在启动的时候，会默认查找`webpack.config.js`，并读取这个文件中配置，来进行打包 module.exports = { // 入口文件 entry: path.resolve(__dirname, './src/main.js'), // 出口文件 output: { // 出口的路径 path: path.resolve(__dirname, 'dist'), // 出口的文件名 filename: 'bundle.js' } } 这样你在项目根目录执行webpack命令就会帮你把main.js给打包成bundle.js然后你以后只需要引入bundle.js就行了,是不是很神奇。 把 main.js打包的意义： 我们可以使用ES6提供的模块化进行代码的编写了。（配置babel之后） 我们可以直接在js文件上引入样式了。 代码美观冗余的代码很少很少了。 大体了解了吧 我们这样配置后有个问题，我们每次修改代码都必须重新打包，一个字：麻烦。 使用 webpack-dev-server来实现代码的实时打包。 首先npm i webpack-dev-server -D安装一下webpack-dev-server 直接输webpack-dev-server会报错，这里我们得借助package.json来进行打包，在scripts下增加\"dev\": \"webpack-dev-server\"指令，然后npm run dev,就能实时打包了。 使用webpack-dev-server的打包是不会产生出口文件的，他是将出口文件放在内存里，这样来做到实时读取和实时打包的。 默认启动端口是8080我们可以webpack-dev-server --port 3000来指定端口 默认启动是在项目根目录，我们可以webpack-dev-server --port 3000 --contentBase src让其在./src中启动 可以配置热更新，就不用每次刷新了，webpack-dev-server --port 3000 --contentBase src --hot 每次都得手动开启浏览器，不喜欢，我们可以让其构建时自动打开浏览器webpack-dev-server --port 3000 --contentBase src --hot --open html文件没进内存-_-!,我们可以配置插件html-webpack-plugin插件 // 导入处理路径的模块var path = require(‘path’);//自动生成html文件var htmlWebpackPlugin = require(‘html-webpack-plugin’);// 导出一个配置对象，将来webpack在启动的时候，会默认查找webpack.config.js，并读取这个文件中配置，来进行打包module.exports = { // 入口文件 entry: path.resolve(dirname, ‘./src/main.js’), // 出口文件 output: { // 出口的路径 path: path.resolve(dirname, ‘dist’), // 出口的文件名 filename: ‘bundle.js’ }, plugins:[ new htmlWebpackPlugin({ //模板路径 template:path.resolve(__dirname, ‘src/index.html’), //生成的HTML文件的名称 filename:’index.html’ }) ]} + 这里就不需要再配置`--contentBase src`了，`html-webpack-plugin`插件会自动把bundle.js注入到index.html页面中！（好玩吧） + 最终在packjson的`script`中增加这个：` \"dev\":\"webpack-dev-server --port 3000 --hot --open\" ` + 除了加命令参数外，我们还可以在配置文件中进行配置增加 1. 第一步在配置项中增加 ```javascript devServer:{ port:3000 hot:true, open:true } 2. 在头部加载`webpack`模块： var webpack = require('webpack'); 3. 在`plugins`下新增插件（热部署）： new webpack.HotModuleReplacementPlugin() 使用webpack来打包css文件+ 是的，css也能打包，包括`less,sacc`都行的只是`loader`不一样 1. 安装需要的`loader`，运行`npm i style-loader css-loader -D` 2. 修改配置文件增加`module`项配置 // 配置第三方loader模块 module: { rules: [ { // 正则匹配所有的.css文件 test: /\\.css$/, //处理css文件的loader use: ['style-loader', 'css-loader'] } ] } 注意：use表示使用哪些loader来处理test所匹配到的文件；use 中相关loader模块的调用顺序是从后向前调用的；（自己第一次的时候就入坑了） 使用webpack打包less文件 下载需要的loadernpm i less-loader less -D 修改配置文件： module: { rules: [ { // 正则匹配所有的.css文件 test: /\\.css$/, //处理css文件的loader use: ['style-loader', 'css-loader'] }, { test: /\\.less$/, use: ['style-loader', 'css-loader', 'less-loader'] } ] } 使用webpack打包sass文件 下载需要的loadernpm i sass-loader node-sass -D 修改配置文件： //在module下的rules增加如下代码 { test: /\\.scss$/, use: ['style-loader', 'css-loader', 'sass-loader'] } 使用webpack处理css中的路径（图片等一系列） 下载需要的loadernpm i url-loader file-loader -D 修改配置文件： //在module下的rules增加如下代码 { test: /\\.(png|jpg|gif)$/, use: 'url-loader' } 默认会将图片转换成base64,可以通过limit设置进行base64编码的图片大小；只有小于指定字节（byte）的图片才会进行base64编码： //在module下的rules增加如下代码 { test: /\\.(png|jpg|gif)$/, use: 'url-loader?limit=43960' }, 使用babel处理高级JS语法 安装需要的loadernpm i babel-core babel-loader babel-plugin-transform-runtime -D 安装转换规则npm i babel-preset-env babel-preset-stage-0 -D 修改配置文件添加相关loader模块，一定要把node_modules文件夹添加到排除： //在module下的rules增加如下代码 { test: /\\.js$/, use: 'babel-loader', //排除node_modules exclude: /node_modules/ } 在项目根目录中添加babel的配置文件.babelrc文件，并修改这个配置文件如下： { //使用何种转换语法 \"presets\":[\"env\", \"stage-0\"], //插件配置 \"plugins\":[\"transform-runtime\"] } 注意：这里使用最新的转换语法babel-preset-env，你看网上很多都用babel-preset-es2015，建议你使用env,它包含了所有的ES相关的语法； 好了webpack的基本配置都说的差不多，不用去记，很多脚手架就能直接给你配好，比如vue-cil，不过如果怕忘欢迎收藏。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[]},{"title":"","slug":"web开发的跨域问题详解/总结知识点","date":"2019-07-17T02:35:31.114Z","updated":"2019-07-18T04:39:25.264Z","comments":true,"path":"2019/07/17/web-kai-fa-de-kua-yu-wen-ti-xiang-jie/zong-jie-zhi-shi-dian/","link":"","permalink":"http://yoursite.com/2019/07/17/web-kai-fa-de-kua-yu-wen-ti-xiang-jie/zong-jie-zhi-shi-dian/","excerpt":"","text":"原型：函数创建后，自身就会产生一个prototype属性，这个属性指向函数的原型对象。在默认情况下，所有原型对象都会自动获得一个constructor（构造函数）属性，这个属性包含一个指向prototype属性所在函数的指针。当调用构造函数创建一个新实例后，该实例的内部将包含一个指针（内部属性），指向构造函数的原型对象。 原型链：由于proto是任何对象都有的属性，所以会形成一条proto连起来的链条，递归访问proto最终到头，并且值是null.其基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。然后层层递进，就构成了实例与原型的链条，这就是所谓原型链的基本概念。闭包闭包属于一种特殊的作用域，能够读取其他函数内部变量的函数。它的定义可以理解为: 父函数被销毁 的情况下，返回出的子函数的[[scope]]中仍然保留着父级的单变量对象和作用域链，因此可以继续访问到父级的变量对象，这样的函数称为闭包。闭包的缺点：滥用闭包函数会造成内存泄露，因为闭包中引用到的包裹函数中定义的变量都永远不会被释放。闭包会产生一个很经典的问题:多个子函数的[[scope]]都是同时指向父级，是完全共享的。因此当父级的变量对象被修改时，所有子函数都受到影响。••解决办法:**变量可以通过 函数参数的形式 传入，避免使用默认的[[scope]]向上查找使用setTimeout包裹，通过第三个参数传入使用 块级作用域，让变量成为自己上下文的属性，避免共享作用域：执行上下文中还包含作用域链。理解作用域之前，先介绍下作用域。作用域其实可理解为该上下文中声明的 变量和声明的作用范围。可分为 块级作用域 和 函数作用域作用域链：我们知道，我们可以在执行上下文中访问到父级甚至全局的变量，这便是作用域链的功劳。作用域链可以理解为一组对象列表，包含 父级和自身的变量对象，因此我们便能通过作用域链访问到父级里声明的变量或者函数。由两部分组成:[[scope]]属性: 指向父级变量对象和作用域链，也就是包含了父级的[[scope]]和AOAO: 自身活动对象如此 [[scopr]]包含[[scope]]，便自上而下形成一条 链式作用域。浅拷贝: 以赋值的形式拷贝引用对象，仍指向同一个地址，修改时原对象也会受到影响Object.assign展开运算符(...)深拷贝: 完全拷贝一个新对象，修改时原对象不再受到任何影响JSON.parse(JSON.stringify(obj)): 性能最快具有循环引用的对象时，报错当值为函数、undefined、或symbol时，无法拷贝递归进行逐一赋值深拷贝: 完全拷贝一个新对象，修改时原对象不再受到任何影响JSON.parse(JSON.stringify(obj)): 性能最快具有循环引用的对象时，报错当值为函数、undefined、或symbol时，无法拷贝递归进行逐一赋值Vue:nextTick在下次dom更新循环结束之后执行延迟回调，可用于获取更新后的dom状态vue-routermodehash historyVue为什么要使用Virtual DOM?重要的原因是为了解耦 HTML依赖，这带来两个非常重要的好处是：不再依赖 HTML 解析器进行模版解析，可以进行更多的 AOT 工作提高运行时效率：通过模版 AOT 编译，Vue 的运行时体积可以进一步压缩，运行时效率可以进一步提升；可以渲染到 DOM 以外的平台，实现 SSR、同构渲染这些高级特性，Weex等框架应用的就是这一特性。更重要的是它使得 Vue 具备了现代框架应有的高级特性。vue 和 react 区别相同点：都支持 ssr，都有 vdom，组件化开发，实现 webComponents 规范，数据驱动等不同点：vue 是双向数据流（当然为了实现单数据流方便管理组件状态，vuex 便出现了），react 是单向数据流。vue的 vdom 是追踪每个组件的依赖关系，不会渲染整个组件树，react每当应该状态被改变时，全部子组件都会 re-render什么是服务端渲染简单理解是将组件或页面通过服务器生成html字符串，再发送到浏览器，最后将静态标记\"混合\"为客户端上完全交互的应用程序使用SSR的好处与坏处1、更利于SEO优化2、更利于首屏渲染3、使用服务端请求首屏数据会比客户端请求更快，因为服务端在内网进行请求，数据响应速度快。客户端在不同网络环境进行数据请求，且外网http请求开销大，导致时间差。 局限性：1、服务端压力较大本来是通过客户端完成渲染，现在统一到服务端node服务去做。尤其是高并发访问的情况，会大量占用服务端CPU资源；2、开发条件受限在服务端渲染中，只会执行到componentDidMount之前的生命周期钩子3、学习成本较高除了对webpack、React要熟悉，还需要掌握node、Koa2等相关技术。相对于客户端渲染，项目构建、部署过程更加复杂。var、let 及 const 区别函数提升优先于变量提升，函数提升会把整个函数挪到作用域顶部，变量提升只会把声明挪到作用域顶部var 存在提升，我们能在声明之前使用。let、const 因为暂时性死区的原因，不能在声明前使用var 在全局作用域下声明变量会导致变量挂载在 window上，其他两者不会let 和 const 作用基本一致，但是后者声明的变量不能再次赋值继承方式：原型继承组合继承子类的构造函数中通过 Parent.call(this) 继承父类的属性，然后改变子类的原型为 new Parent() 来继承父类的函数。这种继承方式优点在于构造函数可以传参，不会与父类引用属性共享，可以复用父类的函数，但是也存在一个缺点就是在继承父类函数的时候调用了父类构造函数，导致子类的原型上多了不需要的父类属性，存在内存上的浪费寄生组合继承的核心就是将父类的原型赋值给了子类，并且将构造函数设置为子类，这样既解决了无用的父类属性问题，还能正确的找到子类的构造函数。Class 继承class 实现继承的核心在于使用 extends 表明继承自哪个父类，并且在子类构造函数中必须调用 super，因为这段代码可以看成 Parent.call(this, value)。Hash模式与History模式的区别Dva的基本使用：webpack的基本使用：Less和Sass的特点及区别：Ajax、fetch、axios的区别： document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[]},{"title":"总结知识点","slug":"总结知识点","date":"2019-07-15T11:00:18.000Z","updated":"2019-07-18T04:39:14.939Z","comments":true,"path":"2019/07/15/zong-jie-zhi-shi-dian/","link":"","permalink":"http://yoursite.com/2019/07/15/zong-jie-zhi-shi-dian/","excerpt":"","text":"原型： 每一个对象都有proto即原型。原型链：由于proto是任何对象都有的属性，所以会形成一条proto连起来的链条，递归访问proto最终到头，并且值是null. 闭包 闭包属于一种特殊的作用域，能够读取其他函数内部变量的函数。它的定义可以理解为: 父函数被销毁 的情况下，返回出的子函数的[[scope]]中仍然保留着父级的单变量对象和作用域链，因此可以继续访问到父级的变量对象，这样的函数称为闭包。 闭包的缺点：滥用闭包函数会造成内存泄露，因为闭包中引用到的包裹函数中定义的变量都永远不会被释放。 闭包会产生一个很经典的问题: 多个子函数的[[scope]]都是同时指向父级，是完全共享的。因此当父级的变量对象被修改时，所有子函数都受到影响。 ••解决办法:** 变量可以通过 函数参数的形式 传入，避免使用默认的[[scope]]向上查找 使用setTimeout包裹，通过第三个参数传入 使用 块级作用域，让变量成为自己上下文的属性，避免共享 作用域： 执行上下文中还包含作用域链。理解作用域之前，先介绍下作用域。作用域其实可理解为该上下文中声明的 变量和声明的作用范围。可分为 块级作用域 和 函数作用域 作用域链： 我们知道，我们可以在执行上下文中访问到父级甚至全局的变量，这便是作用域链的功劳。作用域链可以理解为一组对象列表，包含 父级和自身的变量对象，因此我们便能通过作用域链访问到父级里声明的变量或者函数。 由两部分组成: [[scope]]属性: 指向父级变量对象和作用域链，也就是包含了父级的[[scope]]和AO AO: 自身活动对象 如此 [[scopr]]包含[[scope]]，便自上而下形成一条 链式作用域。 浅拷贝: 以赋值的形式拷贝引用对象，仍指向同一个地址，修改时原对象也会受到影响 Object.assign 展开运算符(...) 深拷贝: 完全拷贝一个新对象，修改时原对象不再受到任何影响 JSON.parse(JSON.stringify(obj)): 性能最快 具有循环引用的对象时，报错 当值为函数、undefined、或symbol时，无法拷贝 递归进行逐一赋值 深拷贝: 完全拷贝一个新对象，修改时原对象不再受到任何影响 JSON.parse(JSON.stringify(obj)): 性能最快 具有循环引用的对象时，报错 当值为函数、undefined、或symbol时，无法拷贝 递归进行逐一赋值 Vue:nextTick 在下次dom更新循环结束之后执行延迟回调，可用于获取更新后的dom状态 vue-routermode hash history Vue为什么要使用Virtual DOM? 重要的原因是为了解耦 HTML依赖，这带来两个非常重要的好处是： 不再依赖 HTML 解析器进行模版解析，可以进行更多的 AOT 工作提高运行时效率：通过模版 AOT 编译，Vue 的运行时体积可以进一步压缩，运行时效率可以进一步提升； 可以渲染到 DOM 以外的平台，实现 SSR、同构渲染这些高级特性，Weex等框架应用的就是这一特性。更重要的是它使得 Vue 具备了现代框架应有的高级特性。 vue 和 react 区别 相同点：都支持 ssr，都有 vdom，组件化开发，实现 webComponents 规范，数据驱动等 不同点： vue 是双向数据流（当然为了实现单数据流方便管理组件状态，vuex 便出现了）， react 是单向数据流。 vue的 vdom 是追踪每个组件的依赖关系，不会渲染整个组件树， react每当应该状态被改变时，全部子组件都会 re-render 什么是服务端渲染简单理解是将组件或页面通过服务器生成html字符串，再发送到浏览器，最后将静态标记”混合”为客户端上完全交互的应用程序 使用SSR的好处与坏处1、更利于SEO优化 2、更利于首屏渲染 3、使用服务端请求首屏数据会比客户端请求更快，因为服务端在内网进行请求，数据响应速度快。客户端在不同网络环境进行数据请求，且外网http请求开销大，导致时间差。 局限性： 1、服务端压力较大 本来是通过客户端完成渲染，现在统一到服务端node服务去做。尤其是高并发访问的情况，会大量占用服务端CPU资源； 2、开发条件受限 在服务端渲染中，只会执行到componentDidMount之前的生命周期钩子 3、学习成本较高 除了对webpack、React要熟悉，还需要掌握node、Koa2等相关技术。相对于客户端渲染，项目构建、部署过程更加复杂。 var、let 及 const 区别 函数提升优先于变量提升，函数提升会把整个函数挪到作用域顶部，变量提升只会把声明挪到作用域顶部 var 存在提升，我们能在声明之前使用。let、const 因为暂时性死区的原因，不能在声明前使用 var 在全局作用域下声明变量会导致变量挂载在 window上，其他两者不会 let 和 const 作用基本一致，但是后者声明的变量不能再次赋值 继承方式： 原型继承组合继承 子类的构造函数中通过 Parent.call(this) 继承父类的属性，然后改变子类的原型为 new Parent() 来继承父类的函数。 这种继承方式优点在于构造函数可以传参，不会与父类引用属性共享，可以复用父类的函数，但是也存在一个缺点就是在继承父类函数的时候调用了父类构造函数，导致子类的原型上多了不需要的父类属性，存在内存上的浪费 寄生组合继承 的核心就是将父类的原型赋值给了子类，并且将构造函数设置为子类，这样既解决了无用的父类属性问题，还能正确的找到子类的构造函数。 Class 继承 class 实现继承的核心在于使用 extends 表明继承自哪个父类，并且在子类构造函数中必须调用 super，因为这段代码可以看成 Parent.call(this, value)。 Hash模式与History模式的区别Dva的基本使用： webpack的基本使用： Less和Sass的特点及区别： Ajax、fetch、axios的区别： document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[]},{"title":"vue+node实现拖拽上传图片","slug":"vue-node实现拖拽上传图片","date":"2019-04-28T11:24:23.000Z","updated":"2019-07-13T12:05:40.127Z","comments":true,"path":"2019/04/28/vue-node-shi-xian-tuo-zhuai-shang-chuan-tu-pian/","link":"","permalink":"http://yoursite.com/2019/04/28/vue-node-shi-xian-tuo-zhuai-shang-chuan-tu-pian/","excerpt":"","text":"一、知识点实现拖拽上传需要用到的知识点如下： 前端 拖拽事件 dataTransfer FileReader FormData progress 后端 multer fs.renameSync 1.H5拖拽事件我们拖动图片放到一个div上时，下列事件会依次发生： dragenter dragover dragleave或drop 只要图片被拖动到div上，就会触发dragenter事件，类似于mouseover事件。 紧接着是dragover事件，而且只要图片在div内移动，就会不停的触发。 如果拖出了div的范围，dragover事件不再发生，但会触发dragleave事件。 如果你拖着图片在div上松手了，就会触发drop事件。 2.dataTransfer对象只有简单的拖放而没有数据变化是莫得用的。我们拖个图片进来的目的是啥？当然是为了获得图片数据，这样才能然后传到服务器上去。于是有了dataTransfer对象，它是事件对象的一个属性，用于从被拖动元素向放置目标传递字符串格式的数据。我们要完成拖拽上传图片就得靠这个对象，因为它是事件对象的属性，所以我们只能在事件处理程序中使用，参考以下代码： //在drop事件中使用dataTransfer对象 onDrop: function(e) { console.log(\"松手\"); var dt = e.dataTransfer; } 3.FormDataMND文档 具体的用法还是得阅读MDN文档好，以下是本菜鸡读了文档后对FormData的理解： 首先明确FomeData是一个对象，由键值对组成，有个append（）方法增加键值，我们可以append字符、数值或是文件 var formData = new FormData(); formData.append(\"name\", \"Ciger\"); formData.append(\"phone\", 123456); //数字123456会被立即转换成字符串 \"123456\" // HTML 文件类型input，由用户选择 formData.append(\"userfile\", fileInputElement.files[0]); append后，我们可通过get()和set()操作对象的值 formData.get('name') // 获取值-> Ciger formData.set('name','Ciger2') //重置值-> Ciger2知道如何使用这个对象了，最关键的就是它有什么用？ formData的作用有两个： 用于发送表单数据，也可独立于表单使用 上传文件 独立于表单使用有点抽象，我们来看代码。 代码里是一个form表单，有两个input输入框加一个提交按钮。通常来说，我们提交数据时要先获取到两个input框的数据，拼接在一起，然后通过ajax发送。 有了FormData对象，两行代码就可以实现form对象数据的拼接 var form = var form=document.querySelector(\"#myForm\");; var data = new FormData(form); 上述代码的data都是form表单里的填的，独立于表单使用即代表我们可以不需要html元素，直接生成数据，然后发送给后端。 来看下面的上传文件代码 var file = e.dataTransfer.files[0] //通过dataTransfer获取拖拽过来的文件 var formData = new FormData() formData.append('file',file) //ajax发送formData ... xhr.send(formData) MDN文档 FileReader对象是用来读取文件的，我们可以通过new FileReader(file)创建一个FileReader对象，file参数代表要读取的文件，可以来自用户在一个元素上选择文件后返回的FileList对象，也可以是拖放操作生成的DataTransfer对象 FileReader有如下事件： onabort onerror onload onloadstart onloadend onprogress 我们可以通过这些事件实现图片的预览，代码如下： var fr = new FileReader(); fr.readAsDataURL(file); fr.onload = function() { console.log(this.result) //这里的this指向是FileReader对象！！！ //这里的this指向是FileReader对象！！！ //这里的this指向是FileReader对象！！！ //将图片的地址src设置为this.result即可 } 注意！！读取后的结果会存在onload事件中的this.result中！ 5.进度事件（Progress）progress事件是针对XHR操作的，会在浏览器接受新数据期间周期性的触发，而onprogress事件处理程序会接收到一个events对象，其target属性是XHR对象，但包含了三个额外的属性 lengthComputable 进度信息是否可用 position 已接收到的字节数 totalSize 根据Content-Length响应头部确定的预期字节数 有了这些信息，我们就可以为用户创建一个上传进度条 var xhr = createXHR(); xhr.onload = function () { if ((xhr.status >= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304) { alert(xhr.responseText); } else { alert(\"Request was unsuccessful: \" + xhr.status); } }; //post一般用来获取上传进度 xhr.upload.onprogress = function(e) { if (e.lengthComputable) { console.log(e.loaded / e.total * 100) } } 二、前端代码&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\" /> &lt;meta name=\"viewport\" content=\"width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0\" /> &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\" /> &lt;link href=\"https://cdn.bootcss.com/bootstrap/4.0.0/css/bootstrap.min.css\" rel=\"stylesheet\" /> &lt;script src=\"https://cdn.bootcss.com/vue/2.5.13/vue.min.js\">&lt;/script> &lt;style> .dropbox { border: 0.25rem dashed #ddd; min-height: 8rem; display: flex; justify-content: flex-start; align-items: center; flex-wrap: wrap; } &lt;/style> &lt;title>Document&lt;/title> &lt;/head> &lt;body> &lt;div id=\"app\" class=\"m-5\"> &lt;div class=\"dropbox p-3\" ref=\"dropbox\"> &lt;h5 v-if=\"files.length===0\" class=\"text-center\" style=\"width:100%;color:#aaa;\" > 将文件拖到这里 &lt;/h5> &lt;div class=\"border m-2 d-inline-block p-4\" style=\"width:15rem;flex:none;\" v-for=\"(file,index) in files\" :key=\"index\" > &lt;h5 class=\"mt-0\">{{ file.name }}&lt;/h5> &lt;img :src=\"file.src\" style=\"width:auto;height:auto;max-width: 100%;max-height: 100%;\" /> &lt;div class=\"progress\" v-if=\"file.showPercentage\"> &lt;div class=\"progress-bar progress-bar-striped\" :style=\"{ width: file.uploadPercentage+'%' }\" >&lt;/div> &lt;/div> &lt;/div> &lt;/div> &lt;/div> &lt;script> new Vue({ el: \"#app\", data: { files: [] }, methods: { uploadFile: function(file, url) { return new Promise((resolve, reject) => { var fr = new FileReader(); var that = this; var item = {}; fr.readAsDataURL(file); fr.onload = function() { item = { src: this.result, name: file.name, uploadPercentage: 0, showPercentage: true }; that.files.push(item); var fd = new FormData(); fd.append(\"file\", file); var xhr = new XMLHttpRequest(); xhr.open(\"POST\", url, true); xhr.upload.addEventListener( \"progress\", function(e) { if (e.loaded == e.total) { item.uploadPercentage = Math.round( (e.loaded * 100) / e.total ); setTimeout(() => { item.showPercentage = false; }, 1000); } else { item.uploadPercentage = Math.round( (e.loaded * 100) / e.total ); } }, false ); xhr.onload = function() { // alert(\"上传完成！\"); }; xhr.send(fd); }; }); }, onDrag: function(e) { e.stopPropagation(); e.preventDefault(); console.log(\"进入\"); this.$refs.dropbox.style = \"border:0.25rem dashed #007bff;\"; }, onDragLeave: function(e) { e.stopPropagation(); e.preventDefault(); console.log(\"离开\"); this.$refs.dropbox.style = \"border:0.25rem dashed #ddd;\"; }, onDrop: function(e) { e.stopPropagation(); e.preventDefault(); console.log(\"松手\"); var url = \"http://127.0.0.1:3000/upload-multiply\"; var dt = e.dataTransfer; for (var i = 0; i !== dt.files.length; i++) { this.uploadFile(dt.files[i], url); } } }, mounted: function() { var dropbox = document.querySelector(\".dropbox\"); dropbox.addEventListener(\"dragenter\", this.onDrag, false); dropbox.addEventListener(\"dragover\", this.onDrag, false); dropbox.addEventListener(\"dragleave\", this.onDragLeave, false); dropbox.addEventListener(\"drop\", this.onDrop, false); } }); &lt;/script> &lt;/body> &lt;/html> 代码解析 HTML部分有个ref=”dropbox”的div，这个就是我们的拖拽区域 ... ... JS部分，mounted的时候,对dropbox添加拖拽事件的监听 mounted: function() { var dropbox = document.querySelector(\".dropbox\"); dropbox.addEventListener(\"dragenter\", this.onDrag, false); dropbox.addEventListener(\"dragover\", this.onDrag, false); dropbox.addEventListener(\"dragleave\", this.onDragLeave, false); dropbox.addEventListener(\"drop\", this.onDrop, false); } 3.methods中实现这几个事件函数 upload(){} //上传文件方法 onDrag(){} onDragLeave(){} onDrop(){} //具体实现看上述代码 三、后端代码var fs = require(\"fs\"); var express = require(\"express\"); var multer = require(\"multer\"); var app = express(); var upload = multer({ dest: \"upload/\" }); //设置跨域访问 app.all(\"*\", function(req, res, next) { res.header(\"Access-Control-Allow-Origin\", \"*\"); res.header(\"Access-Control-Allow-Headers\", \"X-Requested-With\"); res.header(\"Access-Control-Allow-Methods\", \"PUT,POST,GET,DELETE,OPTIONS\"); res.header(\"X-Powered-By\", \" 3.2.1\"); // res.header(\"Content-Type\", \"application/json;charset=utf-8\"); next(); }); // 多图上传 app.post(\"/upload-multiply\", upload.array(\"file\", 2), function(req, res, next) { var files = req.files; var fileName = \"\"; if (files.length > 0) { files.forEach(item => { fileName = new Date().getTime() + \"-\" + item.originalname; fs.renameSync(item.path, __dirname + \"\\\\upload\" + \"\\\\\" + fileName); }); res.send({ code: 1, url: \"127.0.0.1:3000/upload/\" + fileName }); } else { res.send({ code: 0 }); } }); app.listen(3000); 后端需要npm install express multer 运行前要先创建upload文件夹用于存放文件 四、源码与总结源码地址：https://github.com/C-Utopia/pratice-project.git 之前一直对H5的拖拽事件和文件上传迷迷糊糊，所以做了这个小练习。 遇到没做过的东西，首先上网搜索，例如我想实现拖拽上传，那就在百度搜索vue拖拽上传文件之类的关键词，先看看别人如何实现的，复制别人的代码下来看能不能运行，要是能成功运行则仔细阅读源码，源码有没见过的单词，如FormData、FileReader，直接上MDN看文档，了解清楚这个知识点之后再继续阅读源码。 了解清楚拖拽上传的相关知识点以及实现思路，我们再动手写代码就是水到渠成的事了。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"-vue -node","slug":"vue-node","permalink":"http://yoursite.com/tags/vue-node/"}]},{"title":"学习Ajax","slug":"学习Ajax","date":"2019-03-13T14:52:07.000Z","updated":"2019-07-13T11:16:57.235Z","comments":true,"path":"2019/03/13/xue-xi-ajax/","link":"","permalink":"http://yoursite.com/2019/03/13/xue-xi-ajax/","excerpt":"","text":"AJAX的学习、一，XHR简介 在XHR诞生前，网页要获取客户端和服务器的任何状态更新，都需要刷新一次，在XHR诞生后就可以完全通过JS代码异步实现这一过程。 HR是一种浏览器API，极大简化了异步通信的过程，开发者并不需要关注底层的实现，因为浏览器会为我们完成这些工作，如连接管理、协议协商、HTTP请求格式化等等。 XMLHttpRequest 对象提供了对 HTTP 协议的完全的访问，包括做出 POST 和 HEAD 请求以及普通的 GET 请求的能力。XMLHttpRequest 可以同步或异步地返回 Web 服务器的响应，并且能够以文本或者一个 DOM 文档的形式返回内容。原创链接 二，AJAX的简介 AJAX 可以用于创建快速动态的网页。 AJAX 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。 AJAX = 异步 JavaScript 和 XML。 AJAX 是一种用于创建快速动态网页的技术。 通过在后台与服务器进行少量数据交换，AJAX 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。 注意：Ajax 不是一种新的编程语言，而是一种用于创建更好更快以及交互性更强的Web应用程序的技术。 三，AJAX的构造四，XHR创建 XMLHttpRequest 对象 支持大部分浏览器和IE7+ var http = new XMLHttpRequest(); 老版本的 Internet Explorer （IE5 和 IE6） var http = new ActiveXObject(\"Microsoft.XMLHTTP\"); 一，对象创建实例浏览器兼容 var xmlhttp; //定义一个变量用于后面存储对象 if(window.XMLHttpRequest){//如果浏览器支持XMLHttpRequest对象，通常非IE浏览器支持 xmlhttp = new XMLHttpRequest(); }else if(window.ActiveXObject){ //如果浏览器支持ActiveXObject对象，通常是IE try{//尝试创建一个低版本对象，msxml组件2.6版本以下支持 xmlhttp = new ActiveXObject(\"Microsoft.XMLHTTP\"); } catch (e){ try{//尝试创建一个高版本对象，，msxml组件3.0版本以上支持 xmlhttp = new ActiveXObject(\"msxml2.XMLHTTP\"); } catch(x){ } } 二，XHR请求1.AJAX - 向服务器发送请求解释：XMLHttpRequest 对象用于和服务器交换数据。当你的页面全部加载完毕后，客户端会通过 XMLHttpRequest 对象向服务器请求数据，服务器端接受数据并处理后，向客户端反馈数据。2.向服务器发送请求get请求代码： xmlhttp.open(\"GET\",\"ajax.txt\",true); xmlhttp.send(); 避免得到的是缓存的结果只需要在后面加上?t=”+Math.random();如： URL:\"ajax.txt?t=\"+Math.random(), 方法解释： open(method,url,async)method：请求的类型；GET 或 POSTurl：文件在服务器上的位置async：true（异步）或 false（同步） send(string)将请求发送到服务器。string：仅用于 POST 请求在get中一般不填或null. get请求的特点GET 请求可被缓存GET 请求保留在浏览器历史记录中GET 请求可被收藏为书签GET 请求不应在处理敏感数据时使用GET 请求有长度限制GET 请求只应当用于取回数据 希望通过 GET 方法发送信息，请向 URL 添加信息 xmlhttp.open(\"GET\",\"demo_get2.html?fname=Henry&amp;lname=Ford\",true); xmlhttp.send(); post请求代码 xmlhttp.open(\"POST\",\"demo_post.html\",true); xmlhttp.send(); 如果需要像 HTML 表单那样 POST 数据，请使用 setRequestHeader() 来添加 HTTP 头。然后在 send() 方法中规定您希望发送的数据： xmlhttp.open(\"POST\",\"ajax_test.html\",true); xmlhttp.setRequestHeader(\"Content-type\",\"application/x-www-form-urlencoded\"); xmlhttp.send(\"fname=Henry&amp;lname=Ford\"); setRequestHeader(header,value) 向请求添加 HTTP 头。 header: 规定头的名称 value: 规定头的值 三，POST中的SETREQUESTHEADER(HEADER,VALUE)详解1、XMLObject.setRequestHeader “CONTENT-TYPE”, “application/x-www-form-urlencoded” CONTENT-TYPE是什么意思，application/x-www-form-urlencoded是什么意思？ 解答：通常在HTTP协议里，客户端像服务器取得某个网页的时候，必须发送一个HTTP协议的头文件， 告诉服务器客户端要下载什么信息以及相关的参数，如 GET /bb.asp?www=1234 HTTP/1.1 Accept:/ Accept-Language: zh-cn UA-CPU: x86 Accept-Encoding: gzip, deflate User-Agent: Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.2; SV1; .NET CLR 1.1.4322; .NET CLR 2.0.50727) Host:https://ls0904.github.io/ Connection: Keep-Alive Cookie: %C3%F7%CC%EC=%B0%CB;ASPSESSIONIDASDBSDRR=BLEDBIBBCGKBJAKJCFEJKGII 2、XMLObject.setRequestHeader “CONTENT-TYPE”, “application/x-www-form-urlencoded”setRequestHeader “Connection”, “close”这时HTTP头信息就应该是这样了:GET /bb.asp?www=1234 HTTP/1.1Accept: /Accept-Language: zh-cnUA-CPU: x86Accept-Encoding: gzip, deflateUser-Agent: Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.2; SV1; .NET CLR 1.1.4322; .NET CLR 2.0.50727)CONTENT-TYPE:application/x-www-form-urlencodedHost: https://ls0904.github.io/Connection: closeCookie: %C3%F7%CC%EC=%B0%CB;ASPSESSIONIDASDBSDRR=BLEDBIBBCGKBJAKJCFEJKGII关于更多setRequestHeader POST请求的特点POST 请求不会被缓存POST 请求不会保留在浏览器历史记录中POST 不能被收藏为书签POST 请求对数据长度没有要求 四，用GET 还是 POST？与 POST 相比，GET 更简单也更快，并且在大部分情况下都能用。然而，在以下情况中，请使用 POST 请求：无法使用缓存文件（更新服务器上的文件或数据库）向服务器发送大量数据（POST 没有数据量限制）发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠 五，XHR响应1.AJAX服务器响应由于 HTTP 响应是由服务端发出的，并且服务器做出响应需要时间（比如网速慢等原因），所以我们需要监听服务器响应的状态，然后才能进行处理。服务器响应如需获得来自服务器的响应，请使用 XMLHttpRequest 对象的 responseText 或 responseXML 属性。 responseText 获得字符串形式的响应数据。 使用：如果来自服务器的响应并非 XML，请使用 responseText 属性。 实例代码： document.getElementById(\"myDiv\").innerHTML=xmlhttp.responseText; 提示：对于 responseText 属性，只有当 readyState 属性值变为4时，responseText 属性才可用，因为这表明AJAX请求已经结束！ responseXML获得 XML 形式的响应数据。如果来自服务器的响应是 XML，而且需要作为 XML 对象进行解析，请使用 responseXML 属性： responsethis.response获取到的结果会根据this.responType的变化而变化 六，客户端的捕获 AJAX - onreadystatechange 事件 当发送一个请求后，客户端需要确定这个请求什么时候会完成，因此，XMLHttpRequest对象提供了 onreadystatechange 件机制来捕获请求的状态，继而实现响应。 当请求被发送到服务器时，我们需要执行一些基于响应的任务。每当 readyState 改变时，就会触发 onreadystatechange 事件。readyState 属性存有 XMLHttpRequest 的状态信息。 属性介绍 onreadystatechange存储函数（或函数名），每当 readyState 属性改变时，就会调用该函数。 readyState存有 XMLHttpRequest 的状态。从 0 到 4 发生变化。 0: 请求未初始化 1: 服务器连接已建立 2: 请求已接收 3: 请求处理中 4: 请求已完成，且响应已就绪 status200: “OK”404: 未找到页面 当 readyState 等于 4 且状态为 200 时服务器响应已做好被处理的准备时所执行的任务 注意onreadystatechange 事件被触发 5 次（0 - 4），对应着 readyState 的每个变化 0：请求未初始化，还没有调用 open()。 1：请求已经建立，但是还没有发送，还没有调用 send()。 2：请求已发送，正在处理中（通常现在可以从响应中获取内容头）。 3：请求在处理中；通常响应中已有部分数据可用了，没有全部完成。 4：响应已完成；您可以获取并使用服务器的响应了。 五，AJAX中需要记的数字HTTP的状态码含义。 1** 信息，服务器收到请求，需要请求者继续执行操作 2** 成功，操作被成功接收并处理 3** 重定向，需要进一步的操作以完成请求 301 Moved Permanently。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替 302 Moved Temporarily。与301类似。但资源只是临时被移动。客户端应继续使用原有URI 304 Not Modified。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源。 4** 客户端错误，请求包含语法错误或无法完成请求 400 Bad Request 由于客户端请求有语法错误，不能被服务器所理解。 401 Unauthorized 请求未经授权。这个状态代码必须和WWW-Authenticate报头域一起使用 403 Forbidden 服务器收到请求，但是拒绝提供服务。服务器通常会在响应正文中给出不提供服务的原因 404 Not Found 请求的资源不存在，例如，输入了错误的URL 5** 服务器错误，服务器在处理请求的过程中发生了错误 500 Internal Server Error 服务器发生不可预期的错误，导致无法完成客户端的请求。 503 Service Unavailable 服务器当前不能够处理客户端的请求，在一段时间之后，服务器可能会恢复正常。可以参考此篇文章 状态码 解释 1 请求收到，继续处理 2 操作成功并处理 200 交易成功 302 在其他地址发现请求数据 400 错误请求，服务器无法理解 401 请求授权失败 403 请求收到，但不给服务 404 资源不存在 500 服务器发生错误 六,JQuery中的ajax一，JQ中一些AJAX的参数method //数据的提交方式：get和posturl //数据的提交路径async //是否支持异步刷新，默认是truedata //需要提交的数据dataType //服务器返回数据的类型，例如xml,String,Json等success //请求成功后的回调函数error //请求失败后的回调函数例子 var a=$.ajax({ type:\"get\", url:\"../test.php\", async:true, success: function(){ //请求成功的回调函数 $(\"#p\").html(\"请求成功！\")} }); $(function(){ setTimeout(function(){ $(\"#c\").html(a.responseText) },4000) })七，ajax的跨域一，同源解释： ajax默认访问同源数据，所谓同源就是同协议，同域名，同端口。如果请求非同源的会报错。ajax只能访问同源 二，SCRIPT标签访问不同源访问不同源，我们可以使用script标签，将script中的src设置为不同源的数据，js,php等等如下列例子是通过访问不同源的数据（即跨域访问） &lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>淘宝提示词&lt;/title> &lt;/head> &lt;body> &lt;input type=\"text\" id=\"keyword\" placeholder=\"请输入关键字\"/> &lt;input type=\"button\" id=\"btn\" value=\"查询\"/> &lt;div class=\"box\">&lt;/div> &lt;script> var btn = document.getElementById(\"btn\"); btn.onclick = function(){ var keyWord = document.getElementById(\"keyword\").value; //创建节点将外源的数据传入此处 var script = document.createElement(\"script\"); script.src = \"https://suggest.taobao.com/sug?q=\"+keyWord+\"&amp;callback=haha\"; //利用window的 window[\"haha\"] = function(data){ var list = \"&lt;ul>\"; for(var i=0; i&lt;data.result.length; i++){ var temp = data.result[i]; var tempSug = temp[0]; list += \"&lt;li>\"+tempSug+\"&lt;/li>\"; } list += \"&lt;/ul>\"; var box = document.querySelector(\".box\"); box.innerHTML = list; }; var head = document.querySelector(\"head\"); head.appendChild(script); }; &lt;/script> &lt;/body> &lt;/html> 新学的window属性window[“haha”] = function(data){}；这个相当于一个方法，本例子的hahaa是callback的回调函数自定义。 三，跨域的封装（SCRIPT） 跨域封装.js function myAjax(obj){ var defaults = { type:\"get\",//传递数据类型 url:\"#\",//跨域地址名 data:{},//访问数据 jsonp:\"callback\",//回调函数 jsonpCallback:\"hao\",//回调函数名 success:function(data){ //服务器返回方法 }, }; //值覆盖将obj覆盖defaults for(var key in obj){ //对对象obj进行遍历 defaults[key]=obj[key];//赋值 }; //参数设置 var params = \"\"; for(var arr in defaults.data){ params += arr +\"=\"+defaults.data[arr]+\"&amp;\"; } //去掉最后的&amp; if(params){ params = params.substring(0,params.length-1); defaults.url+=\"?\" + params; } //添加回调函数值 defaults.url +=\"&amp;\"+defaults.jsonp+\"=\"+defaults.jsonpCallback; console.log(defaults.url); //创建script的节点 var script = document.createElement(\"script\"); script.src = defaults.url; //服务器返回的内容 window[defaults.jsonpCallback] = function(data){ defaults.success(data);//把数据传过去 }; //将script标签放入head标签 var head = document.querySelector(\"head\"); head.appendChild(script); } 跨域的调用 myAjax({ url:\"https://sp0.baidu.com/5a1Fazu8AA54nxGko9WTAnF6hhy/su\",//外域数据所在库 jsonp:\"cb\",//回调函数名 jsonpCallback:\"hehe\", //window[\"hehe\"]名称 data:{wd:keyWord},//关键字 success:function(data){//服务器返回的函数 console.log(data); }); 四，JQUERY的跨域获取对象解释：其实jquery也就是js的封装但没有用到script标签，值的注意的是，dataType是必须要设置为jsonp. $.ajax({ url:\"https://suggest.taobao.com/sug\",//外域数据 data:{q:val},//搜索关键字 success: function(data){//服务器返回的函数 code.... }, dataType:\"jsonp\",//服务器返回的数据类型 jsonp:\"callback\",//回调函数名 jsonpCallback:\"haha\",//服务器返回时在success中的函数名称 }); 例子请求的数据为：https://suggest.taobao.com/sug?q=val&callback=haha 五，JQUERY的跨域获取JSON数据解释：利用jsonp只能获取一个对象的数据，当另域中返回的是一个json数据的话，就不能用jsonp来获取。这时就需要利用后台来获取数据然后返回前台数据具体如下：后台获取 &lt;?php header(\"Content-Type:text/html;charset=utf-8\"); $province =$_GET[\"province\"]; $city = $_GET[\"city\"]; //将中文编码转为encode编码使能够访问到数据： $pro = urlencode($province); $ci = urlencode($city); //将文件内容读入一个字符串中 $a = file_get_contents(\"http://apicloud.mob.com/v1/weather/query?key=2858149d8091c&amp;city=\".$ci.\"&amp;province=\".$pro); //将字符串返 //print_r($a); echo $a; ?> 注释:此方法是将访问的数据作为字符串的形式来返回，还可以用其他的方法。前台数据 var btn = document.querySelector(\"#c\"); btn.onclick =function(){ var pro = $(\"#a\").val(); var ci= $(\"#b\").val(); console.log(\"你好\") ; $.ajax({ type:\"get\", url:\"../phpfile/跨域获取json数据.php?province=\"+pro+\"&city=\"+ci, async:true, dataType:\"json\", success: function(data){ console.log(data); if(data.msg==\"success\"){ $(\"#d\").html(\"查询结果：\"+data.msg+\"--天气为：\"+data.result[0].weather); }else{ $(\"#d\").html(\"请输入正确的省份城市\"); } }, error: function(){ console.log(\"信息获取失败\"); } }); } 跨域总结 细分可分为script标签，jq利用jsonp跨域，jq利用后端获取json数据。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"}],"tags":[{"name":"-Ajax","slug":"Ajax","permalink":"http://yoursite.com/tags/Ajax/"}]},{"title":"webpack配置(下)","slug":"webpack配置-下","date":"2019-02-17T12:29:32.000Z","updated":"2019-07-13T10:51:19.140Z","comments":true,"path":"2019/02/17/webpack-pei-zhi-xia/","link":"","permalink":"http://yoursite.com/2019/02/17/webpack-pei-zhi-xia/","excerpt":"","text":"使用typescript时需要在根目录下创建一个tsconfig.js的文件 关于.babelrc的配置 直接在webpack.config.js中配置options 创建.babelrc文件，在该文件中配置 注意二者取其一就行了，当然也可以两者互补，只要两者合并起来能满足配置需求即可 在webpack.config.js中的配置是这样的： { test: /\\.js$/, // normal 普通的 loader use: { loader: 'babel-loader', options: { // 用babel-loader 需要把 es6 -> es5 presets: [ '@babel/preset-env', '@babel/preset-react' ], plugins: [ [\"@babel/plugin-proposal-decorators\", { \"legacy\": true }], // 装饰器语法 [\"@babel/plugin-proposal-class-properties\", { \"loose\": true }], // 支持 class 语法 \"@babel/plugin-transform-runtime\", // 运行时，支持 promise 或 gen* \"@babel/plugin-syntax-dynamic-import\", // 支持 import then 语法 ] } }, include: path.resolve(__dirname, '../src'), // 指定为 src 文件 exclude: /node_modules/, // 排除 node_modules } 在.babelrc中的配置是这样的： { presets: [ '@babel/preset-env', '@babel/preset-react' // 使用react必须配置的presets项 ], plugins: [ [\"@babel/plugin-proposal-decorators\", { \"legacy\": true }], // 装饰器语法 [\"@babel/plugin-proposal-class-properties\", { \"loose\": true }], // 支持 class 语法 \"@babel/plugin-transform-runtime\", // 运行时，支持 promise 或 gen* \"@babel/plugin-syntax-dynamic-import\", // 支持 import then 语法 ] } 终于可以摆脱脚手架了。。。。。*(幼稚的想法) hash、chunkhash和contenthash的配置 hash 计算是跟整个项目的构建相关，也就是说如果配置的是hash，那么只要项目中一个文件发生变化，那么所有的hash都会发生变化，这对缓存来说是一种浪费，使用hash时所有的hash值都是一样的，发生变化时一起变化 chunkhash 就是解决上面这个问题的，它根据不同的入口文件( Entry)进行依赖文件解析、构建对应的 chunk，生成对应的哈希值。即一个 chunk里面修改的内容不会影响到另一个 chunk，只有自己这个 chunk的 chunkhash会发生变化 我们更近一步，index.js 和 index.css 同为一个 chunk（index.css是同一个chunk里面抽出来的），如果 index.js 内容发生变化，但是 index.css 没有变化，打包后他们的 hash 都发生变化，这对 css 文件来说是一种浪费。如何解决这个问题呢？contenthash 将根据资源内容创建出唯一 hash，也就是说文件内容不变，hash 就不变。 mini-css-extract-plugin的使用姿势： 先是装包，在plugins里面new出来一个实例 new MiniCssExtractPlugin({ filename: 'index.[contenthash:8].css' // 使用contenthash的好处见上一条 }), 修改rules里面的配置，现在不是用style-loader了，而是要利用mini-css-extract-plugin提供的loader { test: /\\.scss$/, use: [ // 这里替换了原来的style-loader { loader: MiniCssExtractPlugin.loader, options: { hmr: true, reloadAll: true } }, { loader: 'css-loader', options: { modules: true } }, 'sass-loader', 'postcss-loader'], } 如果不抽离css文件那么所有的css样式内容都会在打包后被放在bundle.js文件中，造成的结果就是bundle.js文件内容过大，如果是一个单页应用的话，需要花更多的时间去下载bundle.js，首屏体验就不好，抽离css文件的作用应该就是这个，将css样式的内容抽离出css文件，通过link标签引入index.html中，这样在下载css内容的时候可以继续构建DOM树也可以继续下载后面的bundle.js，阻塞的只是DOM的渲染和bundle.js的执行，总体来说是提升了性能的。 optimize-css-assets-webpack-plugin 这个插件用于对css资源进行压缩，食用方式是在optimization里面进行配置 const OptimizeCss = require('optimize-css-assets-webpack-plugin') const Uglify = require('uglifyjs-webpack-plugin') mode: 'production', optimization: { minimizer: [ new OptimizeCss(), new Uglify(), ], }, 注意：虽然mode已经设置为production，但是使用了optimize-css-assets-webpack-plugin插件之后如果不使用uglifyjs插件的话js文件将无法压缩，展现出来的是和development模式是一样的，当然如果设置的是development模式的话，即使使用了uglifyjs插件也无法压缩。 externals配置 譬如通过标签引入了jQuery的CDN，此时在文件中使用$或者window.$都可以直接使用jQuery，也不需打包进bundle.js，但是如果此时又写了import $ from 'jquery'（纯属为了看着顺眼）;的话，jQuery又会被打包进bundle.js，为了避免这样的情况（不用引入的情况偏偏引入了，又不想打包），可以通过配置externals属性来忽略一些不需要打包的内容 externals: { jquery: '$', } 在处理图片时，有三种情况 在 js文件中创建 img，然后添加进 DOM tree import imgSrc from './a.jpg'; const image = new Image() image.src = imgSrc 在 css文件中作为 background使用 { backgroung: url('./a.jpg'); // 此时不需要先引入，是因为css-loader已经做了这一步操作 } 在 html文件中直接使用 为了将该 src转化为图片打包后的地址，使用一个 loader： html-withimg-loader { test: /\\.html$/, loader: 'html-withimg-loader' } 注意：在配置webpack.config.js时可以像下面这样配置，但是虽然我们只使用了url-loader，但是需要同时装包file-loader，因为由于limit的限制，当图片文件大于200K时会使用file-loader打包出一个图片文件放在build文件夹下，图片大小小于limit限制时是以base64的形式打包进bundle.js文件，也就是说url-loader里面可能会使用到file-loader，这样做的目的也是为了防止bundle.js文件过大，另一个原因是图片过大时编码需要的时间较长，影响打包的速度。但是如果图片较多，会发很多 http 请求，会降低页面性能，所以当图片体积较小时 url-loader 会将引入的图片编码，转为 base64 字符串。再把这串字符打包到文件中，最终只需要引入这个文件就能访问图片了，节省了图片请求。 ``` { test: /\\.(jpg|png|gif)$/, use: { loader: 'url-loader', options: { limit: 200*1024, outputPath: 'img/' // 会在build目录下创建一个img目录 } } }, ``` 关于publicPath的配置，这是代码上线后将资源托管在CDN服务器上，此时html文件中引入各个bundle.js文件不再是本地引入，而是要去CDN服务器上引入，如果继续写成./bundle.js就无法获取到资源，所以就要给所有的引入路径添加上一个公共的路径，譬如说放在http://www.navyblue.com/的CDN服务器上，那么publicPath就设置为http://www.navyblue.com/，这时候在html引入bundle.js的时候就会自动去引入http://www.navyblue.com/bundle.js。如果在output中配置publicPath那么打包出来的所有结果被引入时都会加上公共路径，如果想单独配置，譬如说只给图片加，那么就可以在url-loader的options里面配置 { test: /\\.(jpg|png|gif)$/, use: { loader: 'url-loader', options: { limit: 200*1024, outputPath: 'img/', // 会在build目录下创建一个img目录 publicPath: 'http://www.navyblue.com/' } } }, 关于chunk、bundle、module的区别： module好理解，就是需要被打包的一个个模块 bundle就是打包出来的一个个js文件 chunk：一个entrypoint进去以后，根据各种依赖关系形成一大个chunk，如果在打包一个chunk的过程中需要分割代码，那么分割完最后得到的一个个包就是bundle。 关于html-webpack-plugin的使用: 对于多页应用需要new多个plugin出来 new HtmlWebpackPlugin({ template: './src/index.html', minify: { removeAttributeQuotes: true, }, filename: 'home.html', // filename是打包结束后输出的html文件名 chunks: ['main'], // chunks是指该html需要引入的js文件，里面的`main`其实就是一个entrypoint，因为一个entrypoint对应的就是一个chunk }), new HtmlWebpackPlugin({ template: './src/index.html', minify: { removeAttributeQuotes: true, }, filename: 'other.html', chunks: ['sub'], }), resolve的配置： resolve: { // 解析模块的可选项 modules: [ // 模块的查找目录 \"node_modules\", path.resolve(__dirname, \"app\") ], extensions: [\".js\", \".json\", \".jsx\", \".css\"], // 用到的文件的扩展 alias: { // 模块别名列表 \"module\": \"new-module\" // 用到的别名：真正的路径 }, }, production mode(生产模式) 可以开箱即用地进行各种优化。 包括压缩，作用域提升，tree-shaking 等。 对于cacheGroups的配置: splitChunks: { chunks: 'all', minSize: 50000, minChunks: 2, // 内部的minChunks可以覆盖这里的minChunks cacheGroups: { lodash: { name: 'mylodash', test: /[\\\\/]node_modules[\\\\/]lodash/, // 选择匹配的模块 // 譬如第一个包打包的只有lodash，因为没匹配到react所以不会分割到这个包里 minChunks: 1, priority: 10, // 打包会根据priority的大小从大到小打包 }, react: { name: 'myreact', test: /[\\\\/]node_modules[\\\\/]react/, minChunks: 1, priority: 5, }, vendors: { name: 'myGroups', test: /[\\\\/]node_modules1[\\\\/]/, priority: -10, minChunks: 1, }, default: { name: 'default', // 默认有个default配置，但是如果显示写出来又全都没匹配中的话会再次调用一个隐式的default minChunks: 1, priority: -20, } } }, @babel/polyfill Babel默认只转换新的JavaScript句法（syntax），而不转换新的API，比如Iterator、Generator、Set、Map、Proxy、Reflect、Symbol、Promise等全局对象，以及一些定义在全局对象上的方法（比如Object.assign）都不会转码。 举例来说，ES6在Array对象上新增了Array.from方法。Babel就不会转码这个方法。如果想让这个方法运行，必须使用@babel-polyfill，为当前环境提供一个垫片，使得在当前环境下可以执行该方法。 关于CSS代码 css-loader:负责解析 CSS 代码，主要是为了处理 CSS 中的依赖，例如 @import 和 url() 等引用外部文件的声明 style-loader 会将 css-loader 解析的结果转变成 JS 代码，运行时动态插入 style 标签来让 CSS 代码生效。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"}],"tags":[{"name":"-webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"}]},{"title":"webpack配置(上)","slug":"webpack配置-上","date":"2019-02-03T11:24:55.000Z","updated":"2019-07-13T10:36:31.954Z","comments":true,"path":"2019/02/03/webpack-pei-zhi-shang/","link":"","permalink":"http://yoursite.com/2019/02/03/webpack-pei-zhi-shang/","excerpt":"","text":"clean-webpack-plugin的正确使用姿势： const { CleanWebpackPlugin } = require('clean-webpack-plugin'); 答应我，不会用的去看看文档好吧。。。 optimization里面的相关配置： 设置minChunks指的是有几个entrypoint进去形成的chunk用到了该module，如果达到了该值就会进行分割。 chunks的参数有async（默认，对异步引入的module进行分割），initial（对同步引入的module进行分割），all（对所有形式引入的module进行分割） webpack4`中的`production`模式其实已经默认采用了`uglifyjs 在进行异步引入操作时需要引进新的插件npm install @babel/plugin-syntax-dynamic-import -D，并修改babel配置： { \"presets\": [[\"@babel/preset-env\", { \"corejs\": 2, \"useBuiltIns\": \"usage\" }]], \"plugins\": [\"@babel/plugin-syntax-dynamic-import\"] } magic comments webpackChunkname webpackPrefetch: prefetch chunk 会在父 chunk 加载结束后开始加载。 webpackPreload: preload chunk 会在父 chunk 加载时，以并行方式开始加载。 package.json里面的scripts配置： \"scripts\": { \"build\": \"webpack --config ./config/webpack.config.js\", \"dev\": \"webpack-dev-server --config ./config/webpack.config.js\" }, 设置postcss需要几步操作： npm install postcss-loader autoprefixer -D 在根目录下添加postcss.config.js，并添加以下代码： module.exports = { plugins: [require('autoprefixer')] } 修改webpack.config.js里面的配置： { test: /\\.(sass|scss)$/, use: ['style-loader','css-loader','sass-loader','postcss-loader'] // 顺序不能变 } 设置css模块的模块化： 修改webpack.config.js的配置： { test: /\\.scss$/, use: ['style-loader', { loader: 'css-loader', options: { modules: true } }, 'sass-loader', 'postcss-loader'], } 修改index.js里面引入css文件的方式：原理其实就是在打包css文件的时候修改以下css文件里面的类名来防止命名的冲突，如此一来使用时就需要动态的使用类名了 import style from './index.scss'; document.querySelector('.d2').classList.add(style.d2) 配置sourceMap： source-map: 最大而全，会生成独立的map文件，精确到行和列，打包速度慢 cheap-sourse-map: 相对于上面这种区别在于映射到行为止，打包速度快一些，也会产生独立的map文件 inline-source-map: 映射文件以 base64 格式编码，加在 bundle 文件最后，不产生独立的 map 文件。加入 map 文件后，我们可以明显的看到包体积变大了； cheap-module-eval-source-map: 这个一般是开发环境（dev）推荐使用，在构建速度报错提醒上做了比较好的均衡。 cheap-module-source-map: 一般来说，生产环境是不配 source-map 的，如果想捕捉线上的代码报错，我们可以用这个 eval: 打包后的模块都使用 eval() 执行，行映射可能不准；不产生独立的 map 文件 cheap`: `map` 映射只显示行不显示列，忽略源自 `loader` 的 `source map inline: 映射文件以 base64 格式编码，加在 bundle 文件最后，不产生独立的 map 文件 module: 增加对 loader source map 和第三方模块的映射 webpack可视化打包结果： npm install webpack-bundle-analyzer -D const { BundleAnalyzerPlugin } = require('webpack-bundle-analyzer') 关于tree shaking: 首先tree shaking只有在es6模块中才会适用，因为es6模块是编译时加载的，支持静态分析，而以往的commonjs模块则是运行时加载，不能静态分析，也就无法进行tree shaking了 import命令输入的变量都是只读的，因为它的本质是输入接口。也就是说，不允许在加载模块的脚本里面，改写接口。但是如果import进来的是一个对象，那么改变属性是可以做到的，但是极力不推荐这么做，因为会影响到其他使用该变量的模块。 export语句输出的接口，与其对应的值是动态绑定关系，即通过该接口，可以取到模块内部实时的值。 import语句是应该写在顶层作用域的，（否则会报错）只有这样才可以支持静态分析，但是可以通过polyfill的方式来支持在块作用域内使用import。 关于配置proxy的坑： proxy: { '/api/ganhuo': { target: 'http://gank.io/api', changeOrigin: true, } } 一开始是像上面这样写的proxy，目标请求地址是http://gank.io/api/xiandu/categories，但是在代码中这样axios.get('/api/ganhuo/xiandu/categories')请求时会报404错误，原因是什么呢？把proxy配置修改成下面这样就可以了： proxy: { '/api/ganhuo': { target: 'http://gank.io/api', changeOrigin: true, pathRewrite: { '^/api/ganhuo': '' } } } 因为不写pathRewrite时，相当于webpack认出了/api/gank开头的内容，知道需要代理到http://gank.io/api，但是问题在于，webpack只是简单的把请求的/api/ganhuo/xiandu/categories拼接到了http://gank.io/api后面，最后请求的目标就是http://gank.io/api/api/ganhuo/xiandu/categories，很明显是不对的，所以需要写一个pathRewrite 后续内容请阅读 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"}],"tags":[{"name":"-webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"}]},{"title":"web开发的跨域问题详解","slug":"web开发的跨域问题详解","date":"2019-01-24T10:02:24.000Z","updated":"2019-07-13T10:22:33.897Z","comments":true,"path":"2019/01/24/web-kai-fa-de-kua-yu-wen-ti-xiang-jie/","link":"","permalink":"http://yoursite.com/2019/01/24/web-kai-fa-de-kua-yu-wen-ti-xiang-jie/","excerpt":"","text":"应该都遇到过跨域的问题，当我们从一个域名向另一个域名发送 Ajax 请求的时候，打开浏览器控制台就会看到跨域错误，今天我们就来聊聊跨域的问题。 1. 浏览器的同源策略同源的定义是：如果两个页面的协议，端口（如果有指定）和域名都相同，则两个页面具有相同的源。同源策略限制了从同一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的重要安全机制。 2. 跨域错误信息产生的原因为了说明问题，我们可以做如下实验，我们在本地搭建了开发环境， 由客户端 http://localhost:3001 向服务器 http://localhost:3000 发送两个请求，一个使用 javascript 异步请求数据，另一个使用 img 标签请求数据，服务器收到请求后，打印接收到请求的日志，如下图所示： 客户端发送两个请求 服务端打印日志并处理请求 代开客户端浏览器的控制台，可以看到发出了两个请求，并且都收到了状态码为 200 的响应，同时控制台报了一个错误，即 xhr 请求报错。由此我们可以知道，之所以产生跨域错误信息，原因有以下三条： 浏览器端的限制（服务端收到了请求并正确返回） 发送的是 XMLHttpRequest 请求（使用 img 标签发送的请求为 json 类型，并不会报错） 请求了不同域的资源 只有同时满足了这三个条件，浏览器才会产生跨域错误。 3. 解决跨域的思路既然我们知道了跨域错误产生的原因，那么解决思路就很直观了，针对出错的三个原因进行相应的处理即可，相应的解决思路也有三个方向： 打破浏览器的限制 不发送 XHR 请求 解决跨域 下文将分别进行阐述。 3.1 打破浏览器的限制由上面分析结论可知，之所以出现跨域的错误，实际上是客户端浏览器所做的限制，服务器并未进行限制，因此我们可以通过设置浏览器，使其不进行跨域检查。实际上浏览器也提供了对应的设置选项。 以 MacOS 下的 Chrome 浏览器为例，在终端中使用命令 open -n /Applications/Google\\ Chrome.app/ --args --disable-web-security --user-data-dir=/Users/your-computer-account/MyChromeDevUserData/ 打开浏览器，即可禁用 Chrome 浏览器的安全检查功能，同时也会禁用跨域安全检查功能，这样再次拿前面的例子进行测试，发现此时不会报错，同时也可以正确拿到服务端返回的数据。 禁用浏览器安全检查功能 这种方式虽然可以实现跨域，但是需要每个用户都对浏览器进行设置，同时可能导致潜在的安全隐患，正常情况下不实用。但这个例子充分说明了，跨域错误是前端浏览器所做的限制，与后台服务无关。 3.2 JSONP实现跨域根据思路2，既然跨域问题产生的原因是因为客户端发送了 Ajax 请求，那么我们打破这个条件即可。具体实现方式就是使用 JSONP 来进行跨域请求。 JSONP，是 JSON with Padding 的简称，它是 json 的一种补充使用方式，利用 script 标签来解决跨域问题。JSONP 是非官方协议，他只是前后端一个约定，如果请求参数带有约定的参数，则后台返回 javascript 代码而非 json 数据，返回代码是函数调用形式，函数名即约定值，函数参数即要返回的数据。 JSONP 的实现原理如下图所示： JSONP实现原理 首先在客户端 js 中定义一个函数（假设名为 handler），然后动态创建一个 script 标签插入页面中，script 标签的 src 属性即要调用的地址，同时，在调用的 url 中加入一个服务端约定的参数（假设名为 callback，参数值为已定义的函数名 handler），服务端收到请求，如果发现请求的 url 中带有约定的参数，那么就返回一段函数调用形式的 javascript 代码，该段代码的函数名即为 callback 参数的值 handler，函数的参数即为待返回的数据。这样，客户端拿到返回结果后就会执行 handler 函数，对返回的数据进行处理。 我们使用 jquery 向服务端发送一个 JSONP 格式的请求，从浏览器控制台可以看到请求和对应的响应，如下图所示： JSONP请求的响应 由上图可以看到，发送JSONP请求时，请求的 Type 为 script 类型而非 xhr 类型，这样就打破了跨域报错的三个必要条件，不会产生跨域错误，同时也验证了服务端返回的数据格式为 javascript 代码调用的形式，其中 Jquery331045** 这一长串函数名是 jquery 自动生成的。 由于 JSONP 的原理是使用 script 标签来加载数据，所以它的兼容性很好，但是使用 JSONP 来解决跨域问题存在以下缺陷： 只能发送 GET 请求 发送的不是 XHR 请求，这样导致 XHR 请求中的很多事件都无法进行处理 服务端需要改动 3.3 跨域资源共享CORSCORS 是一个 W3C 标准，全称是”跨域资源共享”（Cross-origin resource sharing）。它允许浏览器向跨源服务器，发出 XMLHttpRequest 请求，从而克服了 AJAX 只能同源使用的限制。CORS 基于 http 协议关于跨域方面的规定，使用时，客户端浏览器直接异步请求被调用端服务端，在响应头增加响应的字段，告诉浏览器后台允许跨域。 3.3.4 CORS请求头和响应头总结请求头： Origin： 浏览器发出 Ajax 跨域请求之前会添加此头部，值为发送请求的域 Access-Control-Request-Method：使用了除 GET、POST 请求方法之外的方法，浏览器会添加此头部，值为当前请求方法 Access-Control-Request-Headers：使用了自定义头部或除了Accept、Accept-Language、Content-Language、Content-Type 之外的头部，浏览器会添加此头部，值为当前的请求方法 响应头： Access-Control-Allow-Origin： 表示服务端允许哪些域请求资源 Access-Control-Allow-Methods： 当客户端包含 Access-Control-Request-Method 请求头时，服务端需要响应该头部，值通常由 Reauest 的 header 中 Access-Control-Request-Method 取得 Access-Control-Allow-Headers： 当客户端包含 Access-Control-Request-Headers 请求头时，服务端需要响应该头部，值通常由 Reauest 的 header 中 Access-Control-Request-Headers 取得 Access-Control-Expose-Headers： 指出客户端通过 XHR 对象的 getResponseHeaders 方法可以获取的响应头有哪些 Access-Control-Allow-Credentials： 允许带 cookie 的跨域请求 Access-Control-Max-Age： 预检请求的缓存时间 4. 总结本文介绍了跨域的原因，重点介绍了使用 JSONP 和 CORS 解决跨域问题的方法。除此之外，实际开发中还其他各种解决跨域问题的思路，本质上，这些方法都是打破跨域错误的三个条件，大家可以自行查资料了解一下。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"-跨域","slug":"跨域","permalink":"http://yoursite.com/tags/跨域/"}]},{"title":"Git使用总结","slug":"Git使用总结","date":"2018-07-25T09:34:23.000Z","updated":"2019-07-13T11:18:57.321Z","comments":true,"path":"2018/07/25/git-shi-yong-zong-jie/","link":"","permalink":"http://yoursite.com/2018/07/25/git-shi-yong-zong-jie/","excerpt":"","text":"git的常用指令：​ // 在当前目录新建一个Git代码库 git init // 获取所有远程分支（不更新本地分支，另需merge） git fetch // 下载远程仓库的所有变动 git fetch [remote] // 增加一个新的远程仓库，并命名 git remote add [shortname] [url] // 恢复暂存区的指定文件到工作区 git checkout [file] // 恢复某个commit的指定文件到暂存区和工作区 git checkout [commit] [file] // 新建一个分支，并切换到该分支 git checkout -b [newBranchName] // 显示有变更的文件 git status // 显示暂存区和工作区的差异 git diff // 显示当前分支的版本历史 git log // 暂存当前修改，将所有至为HEAD状态 git stash 新建项目git init git remote add origin http://xxxxx.git git add . git commit git push -u origin master 常用代码提交操作命令// 添加指定文件到暂存区 git add [file1] [file2] // 删除工作区文件，并且将这次删除放入暂存区 git rm [file1] [file2] // 提交暂存区到仓库区 git commit -m [message] // 提交工作区自上次commit之后的变化，直接到仓库区 git commit -a // 取回远程仓库的变化，并与本地分支合并 git pull [remote] [branch] // 上传本地指定分支到远程仓库 git push [remote] [branch] // 合并指定分支到当前分支 git merge [branchName] 查看分支// 查看所有本地分支 git branch // 查看所有远程分支 git branch -r // 查看所有本地分支和远程分支 git branch -a 删除分支// 删除本地分支 git branch -d &lt;branchName>(删除merge了的分支) git branch -D &lt;branchName>(不管它有没有merge） // 删除远程分支 git push origin --delete &lt;branchName> 重命名远程分支// 1)删除远程分支 git push origin --delete &lt;oldBranchName> // 2)重命名本地分支 git branch -m &lt;oldBranchName> &lt;newBranchName> // 3)推送本地分支 git push origin &lt;newBranchName> 修改远程仓库地址// git修改远程仓库地址（http设置密码/更改密码） git remote rm origin // git remote add origin http://[username]:[password]@[git地址].git/ git remote add origin http://username:password@giturl/ 打标签(Tag)// 查看当前仓库的所有标签 git tag // 搜索符合模式的标签 git tag -l 'v0.1.*' // 创建轻量标签 git tag [tagname] git tag v1.0.0 // 创建附注标签 git tag -a v1.0.0 -m \"1.0.0版本\" // 切换到标签, 与切换分支命令相同 git checkout [tagname] git checkout v1.0.1 // 删除标签 git tag -d [tagname] git tag -d v1.0.1 // 将v1.0.0标签提交到git服务器 $ git push origin v1.0.0 // 将本地所有标签一次性提交到git服务器 $ git push origin –tags 撤销分支 (还没有做push操作)// 场景1：执行了git add，未commit git reset HEAD &lt;filename> // 场景2：执行了git commit，撤销到某次Commit git reset [--hard|soft|mixed|merge|keep] [commitID|HEAD] // --hard，则缓存区中不会存储这些修改，git会直接丢弃这部分内容； // --soft，该条commit号之后的所有commit的修改都会退回到git缓存区中； // --mixed ，缓存区和你指定的提交同步，但工作目录不受影响； // 可以使用 git push origin HEAD --force 强制将分区内容推送到远程服务器。 回滚分支 (还原已push的线上代码)场景1：撤销指定文件到指定版本 // 查看指定文件的历史版本 git log &lt;filename> // 回滚到指定commitID git checkout &lt;commitID> &lt;filename> // 如果你每次更新线上，都会打tag，那可以很快的处理 git checkout &lt;tag> 场景2：回滚某次提交方式1：使用reset(reset是指将HEAD指针指到指定提交，历史记录中不会出现放弃的提交记录) // 步骤1 git reset --hard HEAD^ // 回退到上个版本 git reset --hard commit_id // 退到/进到 指定commit id // 步骤2 git push origin master -f // -f 强制覆盖 方式2：使用revert(revert是放弃指定提交的修改，但是会生成一次新的提交，需要填写提交注释，以前的历史记录都在) // 步骤1 git revert &lt;commitID> // 指定commit id git revert HEAD // 上个版本 // 步骤2 git push origin master 场景3：删除某次提交 git rebase -i \"commit id\"^ // 最后的^号，意思是commit id的前一次提交 配置 git config --global -l // 设置名字: git config --global user.name [username] git config --global user.name \"smile\" //设置邮箱地址: git config --global user.email [useremail] git config --global user.email 123456@qq.com 设置和取消代理// 设置 git config --global https.proxy http://127.0.0.1:1080 git config --global https.proxy https://127.0.0.1:1080 //取消 git config --global --unset http.proxy git config --global --unset https.proxy git使用过程中的问题&解决方案问题 解决方案 // git config http.postBuffer *bytes* git config http.postBuffer 524288000 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"}],"tags":[{"name":"-Git","slug":"Git","permalink":"http://yoursite.com/tags/Git/"}]},{"title":"react在前端开发中的优势体现","slug":"react在前端开发中的优势体现","date":"2018-07-01T11:31:16.000Z","updated":"2019-07-13T12:05:40.134Z","comments":true,"path":"2018/07/01/react-zai-qian-duan-kai-fa-zhong-de-you-shi-ti-xian/","link":"","permalink":"http://yoursite.com/2018/07/01/react-zai-qian-duan-kai-fa-zhong-de-you-shi-ti-xian/","excerpt":"","text":"话不多说，直接进入正题，react的核心点：virtual dom虚拟DOM概念 它并不直接对DOM进行操作，引入了一个叫做virtual dom的概念，安插在javascript逻辑和实际的DOM之间，好处是减少DOM操作，减少DOM操作的目的是提高浏览器的渲染性能。 虚拟dom就中小型项目而言，的确从表象上看不出太多的优势，因为它解决的是底层的dom渲染，IO开销问题。但是想想facebook的体量，不难猜出react的诞生是为了解决更复杂更大型的项目开发和管理的。 实际上React和Vue其实也在操作DOM，只是比较高效地在操作DOM而已，虚拟DOM其实最终也会映射到真实DOM，虽然虚拟DOM只会将变化的部分更新到真实DOM，但实际上直接操作DOM也可以通过某些方式去优化，那么： ​ 1、操作data，不直接操作DOM有什么好处？ ​ 更少的代码做更多的事。 ​ 2、操作data会给DOM操作带来什么不好的地方吗？ ​ 不会，但是不是所有功能“使用操作data”都可以代替的。 ​ 3、会不会比直接操作DOM存在什么难度？ ​ 不会有难度，但是思维需要有一些转变。 JSX虽然做了抽象视图，但她是声明式API，能够保证你看一眼就知道组件树的结构，譬如： 这结构还算清楚吧，基本一眼就知道这个一个面板由输入框、列表、摘要组成，而且布局也清楚了，自上而下。而且，通过查看一个源文件就可以知道你的组件将会如何渲染。这是最大的好处，尽管这和 Angular 模板没什么不同。具体参看：ReactJS For Stupid People 之前写UI的时候往往为了性能，要设计很多DOM的操作逻辑，用了react之后，这些都不给你做了，由他的state跟props来传递给VDOM，很省事，更专注于UI层面。 学会了react以及这个JSX语法，你不光可以通过react写web；也可以通过react-native写ios或者android的应用；甚至可以通过react-blessed写terminal可视化应用；当然也可以通过react-native-desktop写桌面应用。因为JSX这种声明式语法实际是在构建一个抽象的视图层，这种抽象可以通过不同适配器适配到各种显示终端，这总够屌吧？ unidirectional data flow-单向数据流 React倡导使用flux模式来进行组件间数据传输，这种做法叫unidirectional data flow(单向数据流)，单向数据流的好处是与之前angularJS提出的two-way data binding相比较而言，因为单向，所以各种变化都是可预计、可控制的。不像two-way data binding那样，变化一但复杂起来，大家都互相触发变化，到最后一个地方变了，你根本猜不出来她还会导致其他什么地方跟着一起变。这个需要大量实践才能有所感受，如果你初学，那听听就算了，不必死磕。 react项目结构更加清晰： virtual dom、redux、action，分部分别存放，就象java写后台查数据本来用jdbc一条sql就搞定,但分成action service dao分门别类地存放,这样维护性好,大公司的代码需要规范,这样出了问题好找原因。 组件化 一切都是component：代码更加模块化，重用代码更容易，可维护性高。 这里就涉及到react的 架构，比如： smart, dumb component 把组件分成两大类 Smart Components(容器)& Dumb Components(颗粒化组件) 这样做的好处: 有助理你分离关注点，这样的话更有助于理解你的app的业务逻辑 和 它的ui 更有助于复用你的dumb组件，你可以将你的dumb组件复用于别的state下，而且这两个state还完全不同 本质上dumb 组件 其实 就是你的app的调色版。。你可以将它们放到一个页面上。。然后让设计师除了app的业务逻辑，样式随便怎么改， 参看文章：Smart and Dumb Components 高阶组件(HOC-higher order component) 高阶组件（HOC）是react中对组件逻辑进行重用的高级技术。但高阶组件本身并不是React API。它只是一种模式，这种模式是由react自身的组合性质必然产生的。 具体而言，高阶组件就是一个函数，且该函数接受一个组件作为参数，并返回一个新的组件 const EnhancedComponent = higherOrderComponent(WrappedComponent); 对比组件将props属性转变成UI，高阶组件则是将一个组件转换成另一个新组件。 好处：使用高阶组件（HOC）解决交叉问题 参看文章：高阶组件 总结下，看看一个人的组件化水准， pure component functional component smart, dumb component higher order component hoc render hijacking 会用 props.children React.children cloneElement 提供 instance method context 并理解react 内部实现原理 懂 setState 是异步的 懂 synthetic event 懂 react-dom 分层和 react 没有关系 懂 reconciler 懂 fiber 具体问题如下： \\1. 怎么抽象一个带搜索，单多选复合，有请求的 Selector，区分 smart 和 dumped。如果我再往上加功能，比如 autocomplete 等 \\2. 怎么实现对表单的抽象，数据验证怎么统一处理 \\3. 用 react 来实现一个可视化编辑器的引擎，怎么设计，怎么抽象与 model 的交互，再引入 redux 呢，怎么支持第三方组件热插拔 \\4. 用 react 和 redux 模拟多人协作的 Todo，node 作为后端，怎么设计 同构、纯粹的javascrip 因为搜索引擎的爬虫程序依赖的是服务端响应而不是JavaScript的执行，预渲染你的应用有助于搜索引擎优化。 react一些常见问题： setState()函数在任何情况下都会导致组件重渲染吗？如果setState()中参数还是原来没有发生任何变化的state呢？ 对setState用得深了，就容易犯错，所以我们开门见山先把理解setState的关键点列出来。 setState不会立刻改变React组件中state的值； setState通过引发一次组件的更新过程来引发重新绘制； 多次setState函数调用产生的效果会合并 setState后，知道reader时，才真正改变state的值 shouldComponentUpdate函数返回false，因为更新被中断，所以不调用render，但是React不会放弃掉对this.state的更新的，依然会更新this.state 传入 setState 函数的第二个参数的作用是什么？ 该函数会在setState函数调用完成并且组件开始重渲染的时候被调用，我们可以用该函数来监听渲染是否完成（一般没有什么卵用） 调用 setState 之后发生了什么？ 在代码中调用setState函数之后，React 会将传入的参数对象与组件当前的状态合并，然后触发所谓的调和过程（Reconciliation）。经过调和过程，React 会以相对高效的方式根据新的状态构建 React 元素树并且着手重新渲染整个UI界面。在 React 得到元素树之后，React 会自动计算出新的树与老树的节点差异，然后根据差异对界面进行最小化重渲染。在差异计算算法中，React 能够相对精确地知道哪些位置发生了改变以及应该如何改变，这就保证了按需更新，而不是全部重新渲染。 用shouldComponentUpdate做优化的意义大吗？shouldComponentUpdate将带来可测量和可感知的提升？ 如果不能，那就别用：你可能应该避免用它。据React团队的说，shouldComponentUpdate是一个保证性能的紧急出口，意思就是你不到万不得已就别用它。具体参考：什么时候使用shouldComponentUpdate方法? 一般情况下setState()确立后总是触发一次重绘，除非在 shouldComponentUpdate() 中实现了条件渲染逻辑。如果使用可变的对象，但是又不能在 shouldComponentUpdate() 中实现这种逻辑，仅在新 state 和之前的 state 存在差异的时候调用 setState() 可以避免不必要的重新渲染。 react异步数据如ajax请求应该放在哪个生命周期？ 对于同步的状态改变，是可以放在componentWillMount，对于异步的，最好好放在componentDidMount。但如果此时有若干细节需要处理，比如你的组件需要渲染子组件，而且子组件取决于父组件的某个属性，那么在子组件的componentDidMount中进行处理会有问题：因为此时父组件中对应的属性可能还没有完整获取，因此就让其在子组件的componentDidUpdate中处理。 具体参考：《react异步数据如ajax请求应该放在哪个生命周期？》 React 中的 keys 是什么，为什么它们很重要？ 在开发过程中，我们需要保证某个元素的 key 在其同级元素中具有唯一性。在 React Diff 算法中 React 会借助元素的 Key 值来判断该元素是新近创建的还是被移动而来的元素，从而减少不必要的元素重渲染。此外，React 还需要借助 Key 值来判断元素与本地状态的关联关系，因此我们绝不可忽视转换函数中 Key 的重要性。 keys 是帮助 React 跟踪哪些项目已更改、添加或从列表中删除的属性。 每个keys 在兄弟元素之间是独一无二的。我们已经谈过几次关于一致化处理（reconciliation）的过程，而且这个一致化处理过程（reconciliation）中的一部分正在执行一个新的元素树与最前一个的差异。keys 使处理列表时更加高效，因为 React 可以使用子元素上的 keys 快速知道元素是新的还是在比较树时才被移动的。 而且 keys 不仅使这个过程更有效率，而且没有keys，React 不知道哪个本地状态对应于移动中的哪个项目。所以当你 map 的时候，不要忽略了 keys 。 受控组件( controlled component )与不受控制的组件( uncontrolled component )有什么区别？ React 的很大一部分是这样的想法，即组件负责控制和管理自己的状态（任何改变代用setSate处理) 那么不受控组件呢？组件数据不全部是setState来处理，还有DOM交互，比如refs这玩意来操控真实DOM 虽然不受控制的组件通常更容易实现，因为您只需使用引用从DOM获取值，但是通常建议您通过不受控制的组件来支持受控组件。 主要原因是受控组件支持即时字段验证，允许您有条件地禁用/启用按钮，强制输入格式，并且更多的是 『the React way』。 描述事件在React中的处理方式 为了解决跨浏览器兼容性问题，您的 React 中的事件处理程序将传递SyntheticEvent 的实例，它是 React 的浏览器本机事件的跨浏览器包装器。 这些 SyntheticEvent 与您习惯的原生事件具有相同的接口，除了它们在所有浏览器中都兼容。有趣的是，React 实际上并没有将事件附加到子节点本身。React 将使用单个事件监听器监听顶层的所有事件。这对于性能是有好处的，这也意味着在更新DOM时，React 不需要担心跟踪事件监听器。 在什么情况下你会优先选择使用 Class Component 而不是 Functional Component？ 在组件需要包含内部状态或者使用到生命周期函数的时候使用 Class Component ，否则使用函数式组件。 简单介绍下react的diff 计算一棵树形结构转换成另一棵树形结构的最少操作，是一个复杂且值得研究的问题。传统 diff 算法通过循环递归对节点进行依次对比，效率低下，算法复杂度达到 O(n^3)，其中 n 是树中节点的总数。O(n^3) 到底有多可怕，这意味着如果要展示1000个节点，就要依次执行上十亿次的比较。这种指数型的性能消耗对于前端渲染场景来说代价太高了！现今的 CPU 每秒钟能执行大约30亿条指令，即便是最高效的实现，也不可能在一秒内计算出差异情况。。React 通过制定大胆的策略，将 O(n^3) 复杂度的问题转换成 O(n) 复杂度的问题。 react的diff 策略： Web UI 中 DOM 节点跨层级的移动操作特别少，可以忽略不计。 拥有相同类的两个组件将会生成相似的树形结构，拥有不同类的两个组件将会生成不同的树形结构。 对于同一层级的一组子节点，它们可以通过唯一 id 进行区分。 基于以上三个前提策略，React 分别对tree diff、component diff以及element diff进行算法优化，事实也证明这三个前提策略是合理且准确的，它保证了整体界面构建的性能。 tree diff： 基于策略一，React 对树的算法进行了简洁明了的优化，即对树进行分层比较，两棵树只会对同一层次的节点进行比较。 既然 DOM 节点跨层级的移动操作少到可以忽略不计，针对这一现象，React 通过 updateDepth 对 Virtual DOM 树进行层级控制，只会对相同颜色方框内的 DOM 节点进行比较，即同一个父节点下的所有子节点。当发现节点已经不存在，则该节点及其子节点会被完全删除掉，不会用于进一步的比较。这样只需要对树进行一次遍历，便能完成整个 DOM 树的比较。 component diff： 如果是同一类型的组件，按照原策略继续比较 virtual DOM tree。 如果不是，则将该组件判断为 dirty component，从而替换整个组件下的所有子节点。对于同一类型的组件，有可能其 Virtual DOM 没有任何变化，如果能够确切的知道这点那可以节省大量的 diff 运算时间，因此 React 允许用户shouldComponentUpdate() 来判断该组件是否需要进行 diff。 element diff: 当节点处于同一层级时，React diff 提供了三种节点操作，分别为：INSERT_MARKUP（插入）、MOVE_EXISTING（移动）和 REMOVE_NODE（删除）。 INSERT_MARKUP，新的 component 类型不在老集合里， 即是全新的节点，需要对新节点执行插入操作。 MOVE_EXISTING，在老集合有新 component 类型，且 element 是可更新的类型，generateComponentChildren 已调用 receiveComponent，这种情况下 prevChild=nextChild，就需要做移动操作，可以复用以前的 DOM 节点。 REMOVE_NODE，老 component 类型，在新集合里也有，但对应的 element 不同则不能直接复用和更新，需要执行删除操作，或者老 component 不在新集合里的，也需要执行删除操作。 总结 React 通过制定大胆的 diff 策略，将 O(n3) 复杂度的问题转换成 O(n) 复杂度的问题； React 通过分层求异的策略，对 tree diff 进行算法优化； React 通过相同类生成相似树形结构，不同类生成不同树形结构的策略，对 component diff 进行算法优化； React 通过设置唯一 key的策略，对 element diff 进行算法优化； 建议，在开发组件时，保持稳定的 DOM 结构会有助于性能的提升； 建议，在开发过程中，尽量减少类似将最后一个节点移动到列表首部的操作，当节点数量过大或更新操作过于频繁时，在一定程度上会影响 React 的渲染性能。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"-react","slug":"react","permalink":"http://yoursite.com/tags/react/"}]},{"title":"React中类组件与函数组件的区别","slug":"React类组件与函数组件的区别","date":"2018-06-19T13:55:09.000Z","updated":"2019-07-13T11:18:58.250Z","comments":true,"path":"2018/06/19/react-lei-zu-jian-yu-han-shu-zu-jian-de-qu-bie/","link":"","permalink":"http://yoursite.com/2018/06/19/react-lei-zu-jian-yu-han-shu-zu-jian-de-qu-bie/","excerpt":"","text":"class Hello extends React.Component { // 用类组件定义一个Hello组件 constructor (props){ super(props); this.state = { }; }; }; render () { return( ) } function Welcome(props) { //用函数组件定义个一个Welcome组件 return &lt;h1>Hello, {props.name}&lt;/h1>; } 函数组件看似只是一个返回值是DOM结构的函数，其实它的背后是无状态组件（Stateless Components）的思想。函数组件中，你无法使用State，也无法使用组件的生命周期方法，这就决定了函数组件都是展示性组件（Presentational Components），接收Props，渲染DOM，而不关注其他逻辑。 函数组件中没有this。所以你再也不需要考虑this带来的烦恼。而在类组件中，你依然要记得绑定this这个琐碎的事情。而要想改变类组件中this得指向，你需要用bing方法去修改，而不能使用apply、call方法。因为后者会立即执行，只有bind是返回一个回调函数。 函数组件更容易理解。当你看到一个函数组件时，你就知道它的功能只是接收属性，渲染页面，它不执行与UI无关的逻辑处理，它只是一个纯函数。而不用在意它返回的DOM结构有多复杂。 性能。目前React还是会把函数组件在内部转换成类组件，所以使用函数组件和使用类组件在性能上并无大的差异。但是，React官方已承诺，未来将会优化函数组件的性能，因为函数组件不需要考虑组件状态和组件生命周期方法中的各种比较校验，所以有很大的性能提升空间。 函数组件迫使你思考最佳实践。这是最重要的一点。组件的主要职责是UI渲染，理想情况下，所有的组件都是展示性组件，每个页面都是由这些展示性组件组合而成。如果一个组件是函数组件，那么它当然满足这个要求。所以牢记函数组件的概念，可以让你在写组件时，先思考这个组件应不应该是展示性组件。更多的展示性组件意味着更多的组件有更简洁的结构，更多的组件能被更好的复用。 类组件可以帮帮助我们实现动态数据的渲染，本身使用得JSX语法可以采用虚拟DOM得方法减少去操作真实DOM得操作可以达到性能优化得作用，同时也可以提高组件得复用性。 是由用类组件还是函数组件你可以按照自己得需求来，当你需要动态得去渲染数据得时候那么你就该用类组件了。如果你只需要去实现某个属性那么你可以考虑用函数组件更为简单一些。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"-react","slug":"react","permalink":"http://yoursite.com/tags/react/"}]},{"title":"yarn的基本用法","slug":"yarn的基本用法","date":"2018-04-05T08:49:52.000Z","updated":"2019-07-13T11:18:43.472Z","comments":true,"path":"2018/04/05/yarn-de-ji-ben-yong-fa/","link":"","permalink":"http://yoursite.com/2018/04/05/yarn-de-ji-ben-yong-fa/","excerpt":"","text":"yarn的基本用法： ## 1、先初始化一个新的项目yarn init 2、添加一个依赖包yarn add [package] yarn add [package]@[version] yarn add [package]@[tag] 3、安装所有的依赖包yarn或者yarn install 4、npm与yarn命令比较 NPM YARN 说明 npm init yarn init 初始化某个项目 npm install yarn install 默认的安装依赖操作 npm install –save yarn add 安装某个依赖，并且默认保存到package. npm uninstall –save yarn remove 移除某个依赖项目 npm install –save-dev yarn add —dev 安装某个开发时依赖项目 npm update –save yarn upgrade 更新某个依赖项目 npm install –global yarn global add 安装某个全局依赖项目 npm publish/login/logout yarn publish/login/logout 发布/登录/登出，一系列NPM Registry操作 npm run yarn run 运行某个命令 总结：Yarn是由Facebook、Google、Exponent 和 Tilde 联合推出了一个新的 JS 包管理工具 ,它弥补 npm 的一些缺陷,主要优点是速度快,安装版本统一,更简洁的输出,更好的语义化. document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"}],"tags":[{"name":"-yarn","slug":"yarn","permalink":"http://yoursite.com/tags/yarn/"}]},{"title":"一步步认识Vuex","slug":"一步步认识Vuex","date":"2018-03-22T06:51:26.000Z","updated":"2019-07-13T11:23:42.042Z","comments":true,"path":"2018/03/22/yi-bu-bu-ren-shi-vuex/","link":"","permalink":"http://yoursite.com/2018/03/22/yi-bu-bu-ren-shi-vuex/","excerpt":"","text":"如图，Vuex看起来是一个仓库，一层一层得关系牵连，其实它就是一个专为vue.js管理得仓库。 一、为什么需要使用Vuex呢？​ 1、项目越写越大，功能越写越复杂，当vue.js应用程序遇到多个组件共享状态时，单向数据流得简洁性很容易被破坏。 ​ 2、组件之间通信很复杂得情况下 ​ 3、项目中使用了路由，并且路由页面组件中需要通信得时候。 ​ 4、项目遇到难点，写不下去得时候就该用vuex了。 二、Vuex的操作流程：​ 1、要先创建仓库，将我们项目中组件上需要恭喜的数据放置到我们仓库中state的位置/ ​ 2、组件要使用仓库中state的数据，就从仓库里面拿出来用。 ​ 3、要修改仓库中state的数据， ​ 1、commit(提交) mutation ​ 2、dispath（派发） action -> commit mutation ​ 4、然后仓库中state数据发生变化，组件就会得到更新 vuex的使用：​ 1、安装vuex npm install --save vuex ​ 2、项目src/store/index.js文件中创建仓库的实例对象 ​ 3、要main.js中new Vue实例的地方 配置一个store的选项，选项的值就是第二步中实例的对象。 三、如何将仓库中的数据拿到组件中去使用​ this.$store就是仓库的实例对象 ​ 1、直接使用this,$store的方式在组件template模板中使用（不推荐） ​ 2、组件中使用计算属性去拿仓库的数据 ​ 3、借助vuex提供的辅助函数mapState ​ mapState([ ])组件的Computed的key必须要跟State中的key一致 ​ mapState ({ })-组件的Computed的key可以自定义如 ​ 4、将组件自身的computed与State的computed结合 …为展开运算符 computed: { ...mapState(['title']), firstName () { return this.name.split('')[0] } }, 四、如何修改仓库中的数据 先需要在仓库中定义我们的mutation 在组件中提交这个mutaion this.$store.commit(‘mutaion的名字’, 要传递的参数) this.$store.commit({ type: mutaion的名字, 其余的参数 }) mapMutations 辅助函数 mutation不允许异步代码的 五、如何在仓库中 写异步代码 (actions) 每一个action里面都可以写异步代码，但是action并不能修改state中的数据，真正修改数据的还是 mutaction 在组件中如何派发这个action this.$store.dispatch(‘action的名字’) 借助mapActions 辅助函数 至此，vuex中的常用的一些入门知识使用算是简单的分享完了，当然了，相信这些只是一些皮毛！只能说是给予刚接触vuex的初学者一个参考与了解吧！有哪里不明白的或不对的，留言下，咱们可以一起讨论、共同学习！ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"-vuex","slug":"vuex","permalink":"http://yoursite.com/tags/vuex/"}]}]}